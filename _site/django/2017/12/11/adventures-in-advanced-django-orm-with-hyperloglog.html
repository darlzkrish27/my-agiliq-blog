<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Adventures in advanced Django ORM with HyperLogLog | Agiliq Blogs</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Adventures in advanced Django ORM with HyperLogLog" />
<meta name="author" content="shabda" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Counting distinct object is a common operation. Most databases and Django make its quite simple to do so. Given appropriate tables or models you would be doing something like select event_type, count(distinct user_id) from github_events group by 1; With appropriateley defined Django model you would do GithubEvents.objects.values( &quot;event_type&quot; ).annotate( distinct_user_count=Count( &quot;user_id&quot;, distinct=True ) ) Count distinct is however quite slow on large datasets. There are a few faster methods which give an approximate count in much less time. HyperLogLog is one of the most common methods. We will try implementing that in Django ORM without going to raw SQL and see how far we can get. (Spoiler: We will go far but won’t be able to do it.) We will use a table of github events. Citusdata has some interesting data sets, they have a Github event data in CSV which we will use today. We will use Postgres. Lets create the table and load the data. CREATE TABLE github_events ( event_id bigint, event_type text, event_public boolean, repo_id bigint, payload jsonb, repo jsonb, user_id bigint, org jsonb, created_at timestamp ); COPY github_events FROM events.csv CSV We then do a insepctdb on created table to get our models. python manage.py inspectdb github_events This gives us class GithubEvents(models.Model): event_id = models.BigIntegerField(blank=True, null=True) event_type = models.TextField(blank=True, null=True) event_public = models.NullBooleanField() repo_id = models.BigIntegerField(blank=True, null=True) payload = models.TextField(blank=True, null=True) # This field type is a guess. repo = models.TextField(blank=True, null=True) # This field type is a guess. user_id = models.BigIntegerField(blank=True, null=True) org = models.TextField(blank=True, null=True) # This field type is a guess. created_at = models.DateTimeField(blank=True, null=True) class Meta: managed = False db_table = &#39;github_events&#39; Change the event_id to be the primary_key. Other fields stay as is event_id = models.BigIntegerField(primary_key = True) To get the HyperLogLog based distinct counts, grouped by event_type we need to the following SQL. SELECT counted_data.event_type, CASE WHEN num_uniques &lt; 2.5 * 512 AND num_zero_buckets &gt; 0 THEN ( ( 0.7213 / (1 + 1.079 / 512) ) * ( 512 * log( 2, (512 :: numeric) / num_zero_buckets ) ) ):: int ELSE num_uniques END AS approx_distinct_count FROM ( SELECT event_type, ( ( pow(512, 2) * ( 0.7213 / (1 + 1.079 / 512) ) ) / ( ( 512 - count(1) ) + sum( pow(2, -1 * bucket_hash) ) ) ):: int AS num_uniques, 512 - count(1) AS num_zero_buckets FROM ( SELECT event_type, hashtext(user_id :: varchar) &amp; (512 - 1) AS bucket_num, 31 - floor( log( 2, min( hashtext(user_id :: varchar) &amp; ~(1 &lt;&lt; 31) ) ) ) AS bucket_hash FROM github_events GROUP BY 1, 2 ) AS bucketed_data GROUP BY 1 ORDER BY 1 ) AS counted_data ORDER BY 1 We will not go into the details of the SQL. This SQL is adapted from Periscopedata, and they have a very nice tutorial here. We will not be discussing the constants used or the algorithm. You should read the Periscopedata article or read the original paper. We will try to convert this SQL to a Django ORM queryset and see how far we can go. This is a pretty advanced SQL with Nested Sub-queries hashtext which is an undocumented Postgres function Bitwise operations Multiple grouping and mathematical functions Trying to convert this to ORM will allow us to use some adavanced Django ORM features. Lets start with the innermost subquery SELECT event_type, hashtext(user_id :: varchar) &amp; (512 - 1) AS bucket_num, 31 - floor( log( 2, min( hashtext(user_id :: varchar) &amp; ~(1 &lt;&lt; 31) ) ) ) AS bucket_hash FROM github_events GROUP BY 1, 2 The hashtext(user_id :: varchar) is used twice, so let us start by implementing that. hashtext is not part of django.contrib.postgres, but we can get it by subclassing Func # Some imports we are going to need for the rest of the tutorial. from django.db.models import (DateTimeField, ExpressionWrapper, F, IntegerField, Value, Min, Count, TextField) from django.db.models.functions import Cast class HashText(Func): function = &#39;HASHTEXT&#39; With this we can do GithubEvents.objects.annotate( hashed_user_id=HashText( Cast(&quot;user_id&quot;, TextField()) ) ) With this we can do: GithubEvents.objects.annotate( hashed_user_id=HashText( Cast(&quot;user_id&quot;, TextField()) ) ).annotate( bucket_number=ExpressionWrapper( F(&quot;hashed_user_id&quot;).bitand(511), output_field=IntegerField() ) ) We are taking the annotated hashed_user_id and applying a bitwise AND. We need to wrap this in a ExpressionWrapper as Django doesn’t have sufficient data to calculate the output field. At this point we have the two fields we need to group on, so we can do GithubEvents.objects.annotate( hashed_user_id=HashText( Cast(&quot;user_id&quot;, TextField()) ) ).annotate( bucket_number=ExpressionWrapper( F(&quot;hashed_user_id&quot;).bitand(511), output_field=IntegerField() ) ).values(&quot;event_type&quot;, &quot;bucket_number&quot;, hashed_user_id=hashed_user_id) Now we need our aggregated bucket hash corresponding to this expression: 31 - floor( log( 2, min( hashtext(user_id :: varchar) &amp; ~(1 &lt;&lt; 31) ) ) ) So we define a new function class, and use it to annotate further class FloorLog2(Func): template = &#39;FLOOR(LOG(2, (%(expressions)s)))&#39; grouped_gs = GithubEvents.objects.annotate( hashed_user_id=HashText( Cast(&quot;user_id&quot;, TextField()) ) ).annotate( bucket_number=ExpressionWrapper( F(&quot;hashed_user_id&quot;).bitand(511), output_field=IntegerField() ) ).values( &quot;event_type&quot;, &quot;bucket_number&quot;, hashed_user_id=F(&quot;hashed_user_id&quot;) ).annotate( bucket_hash=31-FloorLog2( Min(&quot;hashed_user_id&quot;).bitand(2147483647) ) ) Lets look at the generated query str(grouped_gs.query) It gives us &#39;SELECT &quot;github_events&quot;.&quot;event_type&quot;, HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) AS &quot;hashed_user_id&quot;, (HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) &amp; 511) AS &quot;bucket_number&quot;, (31 - FLOOR(LOG(2, ((MIN(HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text)) &amp; 2147483647))))) AS &quot;bucket_hash&quot; FROM &quot;github_events&quot; GROUP BY &quot;github_events&quot;.&quot;event_type&quot;, HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text), (HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) &amp; 511)&#39; Exactly what we want in our innermost subquery. Now we want to get to the middle subquery in our SQL, which is SELECT event_type, ( ( pow(512, 2) * ( 0.7213 / (1 + 1.079 / 512) ) ) / ( ( 512 - count(1) ) + sum( pow(2, -1 * bucket_hash) ) ) ):: int AS num_uniques, 512 - count(1) AS num_zero_buckets FROM ( ... [First Subquery] ) AS bucketed_data GROUP BY 1 ORDER BY 1 Our first attempt to get this, might be to add another level of values and anotate. Doing this we get. class SumPow2(Func): template = &quot;sum(pow(2, -1 * %(expressions)s ))&quot; grouped_qs_2 = grouped_gs.values( &quot;event_type&quot;, bucket_hash=F(&quot;bucket_hash&quot;) ).annotate( num_zero_buckets=512-Count(&quot;event_type&quot;), num_uniques=ExpressionWrapper( 188686.824458612/(512-Count(&quot;event_type&quot;) + SumPow2(&#39;bucket_hash&#39;)), output_field=IntegerField() ) ) str(grouped_qs_2.query) Looking at the generated query we see &#39;SELECT &quot;github_events&quot;.&quot;event_type&quot;, (31 - FLOOR(LOG(2, (MIN((HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) &amp; 2147483647)))))) AS &quot;bucket_hash&quot;, (512 - COUNT(&quot;github_events&quot;.&quot;event_type&quot;)) AS &quot;num_zero_buckets&quot;, (188686.824458612 / ((512 - COUNT(&quot;github_events&quot;.&quot;event_type&quot;)) + sum(pow(2, -1 * (31 - FLOOR(LOG(2, (MIN((HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) &amp; 2147483647)))))) )))) AS &quot;num_uniques&quot; FROM &quot;github_events&quot; GROUP BY &quot;github_events&quot;.&quot;event_type&quot;&#39; This is not what we want. Rather than the nested group by we see only the outher most group by, corresponding to the last values call we added. My next approach was to try wrapping this in a subquery expression - added in Django 1.11, but there is no way to select with a group by from a subquery expression. At this point I gave up as there seemed to be no way to nest group by expressions. (Though I would ove to be wrong on this). I was able to go much further than I initially expected. References HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm HyperLogLog in Pure SQL Distributed count(distinct) with HyperLogLog on Postgres" />
<meta property="og:description" content="Counting distinct object is a common operation. Most databases and Django make its quite simple to do so. Given appropriate tables or models you would be doing something like select event_type, count(distinct user_id) from github_events group by 1; With appropriateley defined Django model you would do GithubEvents.objects.values( &quot;event_type&quot; ).annotate( distinct_user_count=Count( &quot;user_id&quot;, distinct=True ) ) Count distinct is however quite slow on large datasets. There are a few faster methods which give an approximate count in much less time. HyperLogLog is one of the most common methods. We will try implementing that in Django ORM without going to raw SQL and see how far we can get. (Spoiler: We will go far but won’t be able to do it.) We will use a table of github events. Citusdata has some interesting data sets, they have a Github event data in CSV which we will use today. We will use Postgres. Lets create the table and load the data. CREATE TABLE github_events ( event_id bigint, event_type text, event_public boolean, repo_id bigint, payload jsonb, repo jsonb, user_id bigint, org jsonb, created_at timestamp ); COPY github_events FROM events.csv CSV We then do a insepctdb on created table to get our models. python manage.py inspectdb github_events This gives us class GithubEvents(models.Model): event_id = models.BigIntegerField(blank=True, null=True) event_type = models.TextField(blank=True, null=True) event_public = models.NullBooleanField() repo_id = models.BigIntegerField(blank=True, null=True) payload = models.TextField(blank=True, null=True) # This field type is a guess. repo = models.TextField(blank=True, null=True) # This field type is a guess. user_id = models.BigIntegerField(blank=True, null=True) org = models.TextField(blank=True, null=True) # This field type is a guess. created_at = models.DateTimeField(blank=True, null=True) class Meta: managed = False db_table = &#39;github_events&#39; Change the event_id to be the primary_key. Other fields stay as is event_id = models.BigIntegerField(primary_key = True) To get the HyperLogLog based distinct counts, grouped by event_type we need to the following SQL. SELECT counted_data.event_type, CASE WHEN num_uniques &lt; 2.5 * 512 AND num_zero_buckets &gt; 0 THEN ( ( 0.7213 / (1 + 1.079 / 512) ) * ( 512 * log( 2, (512 :: numeric) / num_zero_buckets ) ) ):: int ELSE num_uniques END AS approx_distinct_count FROM ( SELECT event_type, ( ( pow(512, 2) * ( 0.7213 / (1 + 1.079 / 512) ) ) / ( ( 512 - count(1) ) + sum( pow(2, -1 * bucket_hash) ) ) ):: int AS num_uniques, 512 - count(1) AS num_zero_buckets FROM ( SELECT event_type, hashtext(user_id :: varchar) &amp; (512 - 1) AS bucket_num, 31 - floor( log( 2, min( hashtext(user_id :: varchar) &amp; ~(1 &lt;&lt; 31) ) ) ) AS bucket_hash FROM github_events GROUP BY 1, 2 ) AS bucketed_data GROUP BY 1 ORDER BY 1 ) AS counted_data ORDER BY 1 We will not go into the details of the SQL. This SQL is adapted from Periscopedata, and they have a very nice tutorial here. We will not be discussing the constants used or the algorithm. You should read the Periscopedata article or read the original paper. We will try to convert this SQL to a Django ORM queryset and see how far we can go. This is a pretty advanced SQL with Nested Sub-queries hashtext which is an undocumented Postgres function Bitwise operations Multiple grouping and mathematical functions Trying to convert this to ORM will allow us to use some adavanced Django ORM features. Lets start with the innermost subquery SELECT event_type, hashtext(user_id :: varchar) &amp; (512 - 1) AS bucket_num, 31 - floor( log( 2, min( hashtext(user_id :: varchar) &amp; ~(1 &lt;&lt; 31) ) ) ) AS bucket_hash FROM github_events GROUP BY 1, 2 The hashtext(user_id :: varchar) is used twice, so let us start by implementing that. hashtext is not part of django.contrib.postgres, but we can get it by subclassing Func # Some imports we are going to need for the rest of the tutorial. from django.db.models import (DateTimeField, ExpressionWrapper, F, IntegerField, Value, Min, Count, TextField) from django.db.models.functions import Cast class HashText(Func): function = &#39;HASHTEXT&#39; With this we can do GithubEvents.objects.annotate( hashed_user_id=HashText( Cast(&quot;user_id&quot;, TextField()) ) ) With this we can do: GithubEvents.objects.annotate( hashed_user_id=HashText( Cast(&quot;user_id&quot;, TextField()) ) ).annotate( bucket_number=ExpressionWrapper( F(&quot;hashed_user_id&quot;).bitand(511), output_field=IntegerField() ) ) We are taking the annotated hashed_user_id and applying a bitwise AND. We need to wrap this in a ExpressionWrapper as Django doesn’t have sufficient data to calculate the output field. At this point we have the two fields we need to group on, so we can do GithubEvents.objects.annotate( hashed_user_id=HashText( Cast(&quot;user_id&quot;, TextField()) ) ).annotate( bucket_number=ExpressionWrapper( F(&quot;hashed_user_id&quot;).bitand(511), output_field=IntegerField() ) ).values(&quot;event_type&quot;, &quot;bucket_number&quot;, hashed_user_id=hashed_user_id) Now we need our aggregated bucket hash corresponding to this expression: 31 - floor( log( 2, min( hashtext(user_id :: varchar) &amp; ~(1 &lt;&lt; 31) ) ) ) So we define a new function class, and use it to annotate further class FloorLog2(Func): template = &#39;FLOOR(LOG(2, (%(expressions)s)))&#39; grouped_gs = GithubEvents.objects.annotate( hashed_user_id=HashText( Cast(&quot;user_id&quot;, TextField()) ) ).annotate( bucket_number=ExpressionWrapper( F(&quot;hashed_user_id&quot;).bitand(511), output_field=IntegerField() ) ).values( &quot;event_type&quot;, &quot;bucket_number&quot;, hashed_user_id=F(&quot;hashed_user_id&quot;) ).annotate( bucket_hash=31-FloorLog2( Min(&quot;hashed_user_id&quot;).bitand(2147483647) ) ) Lets look at the generated query str(grouped_gs.query) It gives us &#39;SELECT &quot;github_events&quot;.&quot;event_type&quot;, HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) AS &quot;hashed_user_id&quot;, (HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) &amp; 511) AS &quot;bucket_number&quot;, (31 - FLOOR(LOG(2, ((MIN(HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text)) &amp; 2147483647))))) AS &quot;bucket_hash&quot; FROM &quot;github_events&quot; GROUP BY &quot;github_events&quot;.&quot;event_type&quot;, HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text), (HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) &amp; 511)&#39; Exactly what we want in our innermost subquery. Now we want to get to the middle subquery in our SQL, which is SELECT event_type, ( ( pow(512, 2) * ( 0.7213 / (1 + 1.079 / 512) ) ) / ( ( 512 - count(1) ) + sum( pow(2, -1 * bucket_hash) ) ) ):: int AS num_uniques, 512 - count(1) AS num_zero_buckets FROM ( ... [First Subquery] ) AS bucketed_data GROUP BY 1 ORDER BY 1 Our first attempt to get this, might be to add another level of values and anotate. Doing this we get. class SumPow2(Func): template = &quot;sum(pow(2, -1 * %(expressions)s ))&quot; grouped_qs_2 = grouped_gs.values( &quot;event_type&quot;, bucket_hash=F(&quot;bucket_hash&quot;) ).annotate( num_zero_buckets=512-Count(&quot;event_type&quot;), num_uniques=ExpressionWrapper( 188686.824458612/(512-Count(&quot;event_type&quot;) + SumPow2(&#39;bucket_hash&#39;)), output_field=IntegerField() ) ) str(grouped_qs_2.query) Looking at the generated query we see &#39;SELECT &quot;github_events&quot;.&quot;event_type&quot;, (31 - FLOOR(LOG(2, (MIN((HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) &amp; 2147483647)))))) AS &quot;bucket_hash&quot;, (512 - COUNT(&quot;github_events&quot;.&quot;event_type&quot;)) AS &quot;num_zero_buckets&quot;, (188686.824458612 / ((512 - COUNT(&quot;github_events&quot;.&quot;event_type&quot;)) + sum(pow(2, -1 * (31 - FLOOR(LOG(2, (MIN((HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) &amp; 2147483647)))))) )))) AS &quot;num_uniques&quot; FROM &quot;github_events&quot; GROUP BY &quot;github_events&quot;.&quot;event_type&quot;&#39; This is not what we want. Rather than the nested group by we see only the outher most group by, corresponding to the last values call we added. My next approach was to try wrapping this in a subquery expression - added in Django 1.11, but there is no way to select with a group by from a subquery expression. At this point I gave up as there seemed to be no way to nest group by expressions. (Though I would ove to be wrong on this). I was able to go much further than I initially expected. References HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm HyperLogLog in Pure SQL Distributed count(distinct) with HyperLogLog on Postgres" />
<link rel="canonical" href="http://localhost:4000/django/2017/12/11/adventures-in-advanced-django-orm-with-hyperloglog.html" />
<meta property="og:url" content="http://localhost:4000/django/2017/12/11/adventures-in-advanced-django-orm-with-hyperloglog.html" />
<meta property="og:site_name" content="Agiliq Blogs" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-12-11T22:54:38+05:30" />
<script type="application/ld+json">
{"description":"Counting distinct object is a common operation. Most databases and Django make its quite simple to do so. Given appropriate tables or models you would be doing something like select event_type, count(distinct user_id) from github_events group by 1; With appropriateley defined Django model you would do GithubEvents.objects.values( &quot;event_type&quot; ).annotate( distinct_user_count=Count( &quot;user_id&quot;, distinct=True ) ) Count distinct is however quite slow on large datasets. There are a few faster methods which give an approximate count in much less time. HyperLogLog is one of the most common methods. We will try implementing that in Django ORM without going to raw SQL and see how far we can get. (Spoiler: We will go far but won’t be able to do it.) We will use a table of github events. Citusdata has some interesting data sets, they have a Github event data in CSV which we will use today. We will use Postgres. Lets create the table and load the data. CREATE TABLE github_events ( event_id bigint, event_type text, event_public boolean, repo_id bigint, payload jsonb, repo jsonb, user_id bigint, org jsonb, created_at timestamp ); COPY github_events FROM events.csv CSV We then do a insepctdb on created table to get our models. python manage.py inspectdb github_events This gives us class GithubEvents(models.Model): event_id = models.BigIntegerField(blank=True, null=True) event_type = models.TextField(blank=True, null=True) event_public = models.NullBooleanField() repo_id = models.BigIntegerField(blank=True, null=True) payload = models.TextField(blank=True, null=True) # This field type is a guess. repo = models.TextField(blank=True, null=True) # This field type is a guess. user_id = models.BigIntegerField(blank=True, null=True) org = models.TextField(blank=True, null=True) # This field type is a guess. created_at = models.DateTimeField(blank=True, null=True) class Meta: managed = False db_table = &#39;github_events&#39; Change the event_id to be the primary_key. Other fields stay as is event_id = models.BigIntegerField(primary_key = True) To get the HyperLogLog based distinct counts, grouped by event_type we need to the following SQL. SELECT counted_data.event_type, CASE WHEN num_uniques &lt; 2.5 * 512 AND num_zero_buckets &gt; 0 THEN ( ( 0.7213 / (1 + 1.079 / 512) ) * ( 512 * log( 2, (512 :: numeric) / num_zero_buckets ) ) ):: int ELSE num_uniques END AS approx_distinct_count FROM ( SELECT event_type, ( ( pow(512, 2) * ( 0.7213 / (1 + 1.079 / 512) ) ) / ( ( 512 - count(1) ) + sum( pow(2, -1 * bucket_hash) ) ) ):: int AS num_uniques, 512 - count(1) AS num_zero_buckets FROM ( SELECT event_type, hashtext(user_id :: varchar) &amp; (512 - 1) AS bucket_num, 31 - floor( log( 2, min( hashtext(user_id :: varchar) &amp; ~(1 &lt;&lt; 31) ) ) ) AS bucket_hash FROM github_events GROUP BY 1, 2 ) AS bucketed_data GROUP BY 1 ORDER BY 1 ) AS counted_data ORDER BY 1 We will not go into the details of the SQL. This SQL is adapted from Periscopedata, and they have a very nice tutorial here. We will not be discussing the constants used or the algorithm. You should read the Periscopedata article or read the original paper. We will try to convert this SQL to a Django ORM queryset and see how far we can go. This is a pretty advanced SQL with Nested Sub-queries hashtext which is an undocumented Postgres function Bitwise operations Multiple grouping and mathematical functions Trying to convert this to ORM will allow us to use some adavanced Django ORM features. Lets start with the innermost subquery SELECT event_type, hashtext(user_id :: varchar) &amp; (512 - 1) AS bucket_num, 31 - floor( log( 2, min( hashtext(user_id :: varchar) &amp; ~(1 &lt;&lt; 31) ) ) ) AS bucket_hash FROM github_events GROUP BY 1, 2 The hashtext(user_id :: varchar) is used twice, so let us start by implementing that. hashtext is not part of django.contrib.postgres, but we can get it by subclassing Func # Some imports we are going to need for the rest of the tutorial. from django.db.models import (DateTimeField, ExpressionWrapper, F, IntegerField, Value, Min, Count, TextField) from django.db.models.functions import Cast class HashText(Func): function = &#39;HASHTEXT&#39; With this we can do GithubEvents.objects.annotate( hashed_user_id=HashText( Cast(&quot;user_id&quot;, TextField()) ) ) With this we can do: GithubEvents.objects.annotate( hashed_user_id=HashText( Cast(&quot;user_id&quot;, TextField()) ) ).annotate( bucket_number=ExpressionWrapper( F(&quot;hashed_user_id&quot;).bitand(511), output_field=IntegerField() ) ) We are taking the annotated hashed_user_id and applying a bitwise AND. We need to wrap this in a ExpressionWrapper as Django doesn’t have sufficient data to calculate the output field. At this point we have the two fields we need to group on, so we can do GithubEvents.objects.annotate( hashed_user_id=HashText( Cast(&quot;user_id&quot;, TextField()) ) ).annotate( bucket_number=ExpressionWrapper( F(&quot;hashed_user_id&quot;).bitand(511), output_field=IntegerField() ) ).values(&quot;event_type&quot;, &quot;bucket_number&quot;, hashed_user_id=hashed_user_id) Now we need our aggregated bucket hash corresponding to this expression: 31 - floor( log( 2, min( hashtext(user_id :: varchar) &amp; ~(1 &lt;&lt; 31) ) ) ) So we define a new function class, and use it to annotate further class FloorLog2(Func): template = &#39;FLOOR(LOG(2, (%(expressions)s)))&#39; grouped_gs = GithubEvents.objects.annotate( hashed_user_id=HashText( Cast(&quot;user_id&quot;, TextField()) ) ).annotate( bucket_number=ExpressionWrapper( F(&quot;hashed_user_id&quot;).bitand(511), output_field=IntegerField() ) ).values( &quot;event_type&quot;, &quot;bucket_number&quot;, hashed_user_id=F(&quot;hashed_user_id&quot;) ).annotate( bucket_hash=31-FloorLog2( Min(&quot;hashed_user_id&quot;).bitand(2147483647) ) ) Lets look at the generated query str(grouped_gs.query) It gives us &#39;SELECT &quot;github_events&quot;.&quot;event_type&quot;, HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) AS &quot;hashed_user_id&quot;, (HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) &amp; 511) AS &quot;bucket_number&quot;, (31 - FLOOR(LOG(2, ((MIN(HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text)) &amp; 2147483647))))) AS &quot;bucket_hash&quot; FROM &quot;github_events&quot; GROUP BY &quot;github_events&quot;.&quot;event_type&quot;, HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text), (HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) &amp; 511)&#39; Exactly what we want in our innermost subquery. Now we want to get to the middle subquery in our SQL, which is SELECT event_type, ( ( pow(512, 2) * ( 0.7213 / (1 + 1.079 / 512) ) ) / ( ( 512 - count(1) ) + sum( pow(2, -1 * bucket_hash) ) ) ):: int AS num_uniques, 512 - count(1) AS num_zero_buckets FROM ( ... [First Subquery] ) AS bucketed_data GROUP BY 1 ORDER BY 1 Our first attempt to get this, might be to add another level of values and anotate. Doing this we get. class SumPow2(Func): template = &quot;sum(pow(2, -1 * %(expressions)s ))&quot; grouped_qs_2 = grouped_gs.values( &quot;event_type&quot;, bucket_hash=F(&quot;bucket_hash&quot;) ).annotate( num_zero_buckets=512-Count(&quot;event_type&quot;), num_uniques=ExpressionWrapper( 188686.824458612/(512-Count(&quot;event_type&quot;) + SumPow2(&#39;bucket_hash&#39;)), output_field=IntegerField() ) ) str(grouped_qs_2.query) Looking at the generated query we see &#39;SELECT &quot;github_events&quot;.&quot;event_type&quot;, (31 - FLOOR(LOG(2, (MIN((HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) &amp; 2147483647)))))) AS &quot;bucket_hash&quot;, (512 - COUNT(&quot;github_events&quot;.&quot;event_type&quot;)) AS &quot;num_zero_buckets&quot;, (188686.824458612 / ((512 - COUNT(&quot;github_events&quot;.&quot;event_type&quot;)) + sum(pow(2, -1 * (31 - FLOOR(LOG(2, (MIN((HASHTEXT(&quot;github_events&quot;.&quot;user_id&quot;::text) &amp; 2147483647)))))) )))) AS &quot;num_uniques&quot; FROM &quot;github_events&quot; GROUP BY &quot;github_events&quot;.&quot;event_type&quot;&#39; This is not what we want. Rather than the nested group by we see only the outher most group by, corresponding to the last values call we added. My next approach was to try wrapping this in a subquery expression - added in Django 1.11, but there is no way to select with a group by from a subquery expression. At this point I gave up as there seemed to be no way to nest group by expressions. (Though I would ove to be wrong on this). I was able to go much further than I initially expected. References HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm HyperLogLog in Pure SQL Distributed count(distinct) with HyperLogLog on Postgres","author":{"@type":"Person","name":"shabda"},"@type":"BlogPosting","url":"http://localhost:4000/django/2017/12/11/adventures-in-advanced-django-orm-with-hyperloglog.html","headline":"Adventures in advanced Django ORM with HyperLogLog","dateModified":"2017-12-11T22:54:38+05:30","datePublished":"2017-12-11T22:54:38+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/django/2017/12/11/adventures-in-advanced-django-orm-with-hyperloglog.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Agiliq Blogs" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Agiliq Blogs</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/forms.html">Forms</a><a class="page-link" href="/categories/interviews.html">Interviews</a><a class="page-link" href="/categories/marketing.html">Marketing</a><a class="page-link" href="/categories/paypal.html">Paypal</a><a class="page-link" href="/categories/python.html">Python</a><a class="page-link" href="/categories/search.html">Search</a><a class="page-link" href="/categories/startup.html">Startup</a><a class="page-link" href="/categories/uncategorized.html">Uncategorized</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Adventures in advanced Django ORM with HyperLogLog</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-12-11T22:54:38+05:30" itemprop="datePublished">Dec 11, 2017
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">shabda</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Counting distinct object is a common operation. Most databases and Django make its quite simple to do so. Given appropriate tables or models you would be doing something like</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select event_type, count(distinct user_id)
from github_events
group by 1;
</code></pre></div></div>

<p>With appropriateley defined Django model you would do</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GithubEvents.objects.values(
    "event_type"
).annotate(
    distinct_user_count=Count(
        "user_id", distinct=True
    )
)
</code></pre></div></div>

<p>Count distinct is however <a href="https://en.wikipedia.org/wiki/Count-distinct_problem">quite slow on large datasets</a>. There are a few faster methods which give an approximate count in much less time. HyperLogLog is one of the most common methods. We will try implementing that in Django ORM without going to raw SQL and see how far we can get. (Spoiler: We will go far but won’t be able to do it.)</p>

<p>We will use a table of github events. Citusdata has some interesting data sets, they have a <a href="https://examples.citusdata.com/events.csv">Github event data in CSV</a> which we will use today. We will use Postgres.</p>

<p>Lets create the table and load the data.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE github_events
    (
        event_id bigint,
        event_type text,
        event_public boolean,
        repo_id bigint,
        payload jsonb,
        repo jsonb,
        user_id bigint,
        org jsonb,
        created_at timestamp
    );

COPY github_events FROM events.csv CSV
</code></pre></div></div>

<p>We then do a insepctdb on created table to get our models.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python manage.py inspectdb github_events
</code></pre></div></div>

<p>This gives us</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class GithubEvents(models.Model):
    event_id = models.BigIntegerField(blank=True, null=True)
    event_type = models.TextField(blank=True, null=True)
    event_public = models.NullBooleanField()
    repo_id = models.BigIntegerField(blank=True, null=True)
    payload = models.TextField(blank=True, null=True)  # This field type is a guess.
    repo = models.TextField(blank=True, null=True)  # This field type is a guess.
    user_id = models.BigIntegerField(blank=True, null=True)
    org = models.TextField(blank=True, null=True)  # This field type is a guess.
    created_at = models.DateTimeField(blank=True, null=True)

    class Meta:
        managed = False
        db_table = 'github_events'
</code></pre></div></div>

<p>Change the <code class="highlighter-rouge">event_id</code> to be the primary_key. Other fields stay as is</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>event_id = models.BigIntegerField(primary_key = True)
</code></pre></div></div>

<p>To get the HyperLogLog based distinct counts, grouped by event_type we need to the following SQL.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT
  counted_data.event_type,
  CASE WHEN num_uniques &lt; 2.5 * 512
  AND num_zero_buckets &gt; 0 THEN (
    (
      0.7213 / (1 + 1.079 / 512)
    ) * (
      512 * log(
        2,
        (512 :: numeric) / num_zero_buckets
      )
    )
  ):: int ELSE num_uniques END AS approx_distinct_count
FROM
  (
    SELECT
      event_type,
      (
        (
          pow(512, 2) * (
            0.7213 / (1 + 1.079 / 512)
          )
        ) / (
          (
            512 - count(1)
          ) + sum(
            pow(2, -1 * bucket_hash)
          )
        )
      ):: int AS num_uniques,
      512 - count(1) AS num_zero_buckets
    FROM
      (
        SELECT
          event_type,
          hashtext(user_id :: varchar) &amp; (512 - 1) AS bucket_num,
          31 - floor(
            log(
              2,
              min(
                hashtext(user_id :: varchar) &amp; ~(1 &lt;&lt; 31)
              )
            )
          ) AS bucket_hash
        FROM
          github_events
        GROUP BY
          1,
          2
      ) AS bucketed_data
    GROUP BY
      1
    ORDER BY
      1
  ) AS counted_data
ORDER BY
  1
</code></pre></div></div>

<p>We will not go into the details of the SQL. This SQL is adapted from Periscopedata, and <a href="https://www.periscopedata.com/blog/hyperloglog-in-pure-sql">they have a very nice tutorial here</a>.</p>

<p>We will not be discussing the constants used or the algorithm. You should read the Periscopedata article or <a href="algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">read the original paper</a>.</p>

<p>We will try to convert this SQL to a Django ORM queryset and see how far we can go. This is a pretty advanced SQL with</p>

<ol>
  <li>Nested Sub-queries</li>
  <li><code class="highlighter-rouge">hashtext</code> which is an undocumented Postgres function</li>
  <li>Bitwise operations</li>
  <li>Multiple grouping and mathematical functions</li>
</ol>

<p>Trying to convert this to ORM will allow us to use some adavanced Django ORM features.</p>

<p>Lets start with the innermost subquery</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT
  event_type,
  hashtext(user_id :: varchar) &amp; (512 - 1) AS bucket_num,
  31 - floor(
    log(
      2,
      min(
        hashtext(user_id :: varchar) &amp; ~(1 &lt;&lt; 31)
      )
    )
  ) AS bucket_hash
FROM
  github_events
GROUP BY
  1,
  2
</code></pre></div></div>

<p>The <code class="highlighter-rouge">hashtext(user_id :: varchar)</code> is used twice, so let us start by implementing that. <code class="highlighter-rouge">hashtext</code> is not part of <code class="highlighter-rouge">django.contrib.postgres</code>, but we can get it by subclassing <code class="highlighter-rouge">Func</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Some imports we are going to need for the rest of the tutorial.
from django.db.models import (DateTimeField, ExpressionWrapper, F,
     IntegerField, Value, Min, Count, TextField)
from django.db.models.functions import Cast

class HashText(Func):
    function = 'HASHTEXT'
</code></pre></div></div>

<p>With this we can do</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GithubEvents.objects.annotate(
    hashed_user_id=HashText(
        Cast("user_id", TextField())
    )
)
</code></pre></div></div>

<p>With this we can do:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GithubEvents.objects.annotate(
    hashed_user_id=HashText(
        Cast("user_id", TextField())
    )
).annotate(
    bucket_number=ExpressionWrapper(
        F("hashed_user_id").bitand(511), output_field=IntegerField()
    )
)
</code></pre></div></div>

<p>We are taking the annotated <code class="highlighter-rouge">hashed_user_id</code> and applying a bitwise AND. We
need to wrap this in a <code class="highlighter-rouge">ExpressionWrapper</code> as Django doesn’t have sufficient data to calculate the output field.</p>

<p>At this point we have the two fields we need to group on, so we can do</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GithubEvents.objects.annotate(
    hashed_user_id=HashText(
        Cast("user_id", TextField())
    )
).annotate(
    bucket_number=ExpressionWrapper(
        F("hashed_user_id").bitand(511), output_field=IntegerField()
    )
).values("event_type", "bucket_number", hashed_user_id=hashed_user_id)
</code></pre></div></div>

<p>Now we need our aggregated bucket hash corresponding to this expression:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>31 - floor(
    log(
      2,
      min(
        hashtext(user_id :: varchar) &amp; ~(1 &lt;&lt; 31)
      )
    )
  )
</code></pre></div></div>

<p>So we define a new function class, and use it to annotate further</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class FloorLog2(Func):
    template = 'FLOOR(LOG(2, (%(expressions)s)))'

grouped_gs = GithubEvents.objects.annotate(
    hashed_user_id=HashText(
        Cast("user_id", TextField())
    )
).annotate(
    bucket_number=ExpressionWrapper(
        F("hashed_user_id").bitand(511), output_field=IntegerField()
    )
).values(
    "event_type", "bucket_number",
    hashed_user_id=F("hashed_user_id")
).annotate(
    bucket_hash=31-FloorLog2(
        Min("hashed_user_id").bitand(2147483647)
    )
)
</code></pre></div></div>

<p>Lets look at the generated query</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>str(grouped_gs.query)
</code></pre></div></div>

<p>It gives us</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'SELECT "github_events"."event_type", HASHTEXT("github_events"."user_id"::text) AS "hashed_user_id", (HASHTEXT("github_events"."user_id"::text) &amp; 511) AS "bucket_number", (31 - FLOOR(LOG(2, ((MIN(HASHTEXT("github_events"."user_id"::text)) &amp; 2147483647))))) AS "bucket_hash" FROM "github_events" GROUP BY "github_events"."event_type", HASHTEXT("github_events"."user_id"::text), (HASHTEXT("github_events"."user_id"::text) &amp; 511)'
</code></pre></div></div>

<p>Exactly what we want in our innermost subquery.</p>

<p>Now we want to get to the middle subquery in our SQL, which is</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT
      event_type,
      (
        (
          pow(512, 2) * (
            0.7213 / (1 + 1.079 / 512)
          )
        ) / (
          (
            512 - count(1)
          ) + sum(
            pow(2, -1 * bucket_hash)
          )
        )
      ):: int AS num_uniques,
      512 - count(1) AS num_zero_buckets
    FROM
      (
        ... [First Subquery]
      ) AS bucketed_data
    GROUP BY
      1
    ORDER BY
      1
</code></pre></div></div>

<p>Our first attempt to get this, might be to add another level of <code class="highlighter-rouge">values</code> and anotate. Doing this we get.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class SumPow2(Func):
    template = "sum(pow(2, -1 * %(expressions)s ))"

grouped_qs_2 = grouped_gs.values(
    "event_type", bucket_hash=F("bucket_hash")
).annotate(
    num_zero_buckets=512-Count("event_type"),
    num_uniques=ExpressionWrapper(
        188686.824458612/(512-Count("event_type") + SumPow2('bucket_hash')), output_field=IntegerField()
    )
)
str(grouped_qs_2.query)
</code></pre></div></div>

<p>Looking at the generated query we see</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'SELECT "github_events"."event_type", (31 - FLOOR(LOG(2, (MIN((HASHTEXT("github_events"."user_id"::text) &amp; 2147483647)))))) AS "bucket_hash", (512 - COUNT("github_events"."event_type")) AS "num_zero_buckets", (188686.824458612 / ((512 - COUNT("github_events"."event_type")) + sum(pow(2, -1 * (31 - FLOOR(LOG(2, (MIN((HASHTEXT("github_events"."user_id"::text) &amp; 2147483647)))))) )))) AS "num_uniques" FROM "github_events" GROUP BY "github_events"."event_type"'
</code></pre></div></div>

<p>This is not what we want. Rather than the nested group by we see only the outher most group by, corresponding to the last <code class="highlighter-rouge">values</code> call we added.</p>

<p>My next approach was to try wrapping this in a subquery expression - <a href="https://docs.djangoproject.com/en/1.11/releases/1.11/">added in Django 1.11</a>, but
there is no way to select with a group by from a subquery expression.</p>

<p>At this point I gave up as there seemed to be no way to nest group by expressions. (Though I would ove to be wrong on this). I was able to go much further than I initially expected.</p>

<h3 id="references">References</h3>

<ul>
  <li><a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">HyperLogLog: the analysis of a near-optimal
cardinality estimation algorithm</a></li>
  <li><a href="https://www.periscopedata.com/blog/hyperloglog-in-pure-sql">HyperLogLog in Pure SQL</a></li>
  <li><a href="https://www.citusdata.com/blog/2017/04/04/distributed_count_distinct_with_postgresql/">Distributed count(distinct) with HyperLogLog on Postgres</a></li>
</ul>


  </div><a class="u-url" href="/django/2017/12/11/adventures-in-advanced-django-orm-with-hyperloglog.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Agiliq Blogs</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Agiliq Blogs</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
