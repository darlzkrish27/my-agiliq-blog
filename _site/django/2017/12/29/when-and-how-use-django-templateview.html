<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.4.0 -->
<title>When and how to use Django TemplateView | Agiliq Blogs</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="When and how to use Django TemplateView" />
<meta name="author" content="akshar" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="When to use Template View? Django provides several class based generic views to accomplish common tasks. Simplest among them is TemplateView. TemplateView should be used when you want to present some information in a html page. TemplateView shouldn’t be used when your page has forms and does creation or update of objects. TemplateView is most suitable in following cases: Showing ‘about us’ like pages which are static and hardly needs any context. Though it is easy to use context variables with TemplateView. Showing pages which work with GET requests and don’t have forms in it. Let’s write a view using base view View and then modify it to use TemplateView. TemplateView would help us avoid several lines of code. Vanilla view An ‘about us’ page with View. from django.views.generic.base import View from django.shortcuts import render class AboutUs(View): def get(self, request, *args, **kwargs): return render(request, &quot;about-us.html&quot;) With vanilla View we need to provide a get() implementation and must return a HttpResponse() object from get(). TemplateView The same functionality can be achieved with TemplateView in following way: from django.views.generic.base import TemplateView class AboutUs(TemplateView): template_name = &#39;about-us.html&#39; As you can notice, we didn’t have to provide a get() implementation while using TemplateView. TemplateView has it’s own get(). TemplateView.get() also encapsulates the creation of HttpResponse object and returning it. We only had to specify the template_name while using TemplateView. An ‘about us’ page with context using a vanilla View. class AboutUs(View): def get(self, request, *args, **kwargs): context = {&#39;name&#39;: &#39;Gryffindor&#39;} return render(request, &quot;about-us.html&quot;, context=context) TemplateView with context variables An ‘about us’ page with context using a TemplateView. class AboutUs(TemplateView): template_name = &#39;about-us.html&#39; def get_context_data(self, *args, **kwargs): context = super(AboutUs, self).get_context_data(*args, **kwargs) context[&#39;name&#39;] = &#39;Gryffindor&#39; return context TemplateView has a better separation of defining context variables and defining template name. Essentially a TemplateView helps you avoid boilerplate code like: providing a GET() implementation. creating a returning a HttpResponse() or a subclass of HttpResponse() object." />
<meta property="og:description" content="When to use Template View? Django provides several class based generic views to accomplish common tasks. Simplest among them is TemplateView. TemplateView should be used when you want to present some information in a html page. TemplateView shouldn’t be used when your page has forms and does creation or update of objects. TemplateView is most suitable in following cases: Showing ‘about us’ like pages which are static and hardly needs any context. Though it is easy to use context variables with TemplateView. Showing pages which work with GET requests and don’t have forms in it. Let’s write a view using base view View and then modify it to use TemplateView. TemplateView would help us avoid several lines of code. Vanilla view An ‘about us’ page with View. from django.views.generic.base import View from django.shortcuts import render class AboutUs(View): def get(self, request, *args, **kwargs): return render(request, &quot;about-us.html&quot;) With vanilla View we need to provide a get() implementation and must return a HttpResponse() object from get(). TemplateView The same functionality can be achieved with TemplateView in following way: from django.views.generic.base import TemplateView class AboutUs(TemplateView): template_name = &#39;about-us.html&#39; As you can notice, we didn’t have to provide a get() implementation while using TemplateView. TemplateView has it’s own get(). TemplateView.get() also encapsulates the creation of HttpResponse object and returning it. We only had to specify the template_name while using TemplateView. An ‘about us’ page with context using a vanilla View. class AboutUs(View): def get(self, request, *args, **kwargs): context = {&#39;name&#39;: &#39;Gryffindor&#39;} return render(request, &quot;about-us.html&quot;, context=context) TemplateView with context variables An ‘about us’ page with context using a TemplateView. class AboutUs(TemplateView): template_name = &#39;about-us.html&#39; def get_context_data(self, *args, **kwargs): context = super(AboutUs, self).get_context_data(*args, **kwargs) context[&#39;name&#39;] = &#39;Gryffindor&#39; return context TemplateView has a better separation of defining context variables and defining template name. Essentially a TemplateView helps you avoid boilerplate code like: providing a GET() implementation. creating a returning a HttpResponse() or a subclass of HttpResponse() object." />
<link rel="canonical" href="http://localhost:4000/django/2017/12/29/when-and-how-use-django-templateview.html" />
<meta property="og:url" content="http://localhost:4000/django/2017/12/29/when-and-how-use-django-templateview.html" />
<meta property="og:site_name" content="Agiliq Blogs" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-12-29T11:30:27+05:30" />
<script type="application/ld+json">
{"description":"When to use Template View? Django provides several class based generic views to accomplish common tasks. Simplest among them is TemplateView. TemplateView should be used when you want to present some information in a html page. TemplateView shouldn’t be used when your page has forms and does creation or update of objects. TemplateView is most suitable in following cases: Showing ‘about us’ like pages which are static and hardly needs any context. Though it is easy to use context variables with TemplateView. Showing pages which work with GET requests and don’t have forms in it. Let’s write a view using base view View and then modify it to use TemplateView. TemplateView would help us avoid several lines of code. Vanilla view An ‘about us’ page with View. from django.views.generic.base import View from django.shortcuts import render class AboutUs(View): def get(self, request, *args, **kwargs): return render(request, &quot;about-us.html&quot;) With vanilla View we need to provide a get() implementation and must return a HttpResponse() object from get(). TemplateView The same functionality can be achieved with TemplateView in following way: from django.views.generic.base import TemplateView class AboutUs(TemplateView): template_name = &#39;about-us.html&#39; As you can notice, we didn’t have to provide a get() implementation while using TemplateView. TemplateView has it’s own get(). TemplateView.get() also encapsulates the creation of HttpResponse object and returning it. We only had to specify the template_name while using TemplateView. An ‘about us’ page with context using a vanilla View. class AboutUs(View): def get(self, request, *args, **kwargs): context = {&#39;name&#39;: &#39;Gryffindor&#39;} return render(request, &quot;about-us.html&quot;, context=context) TemplateView with context variables An ‘about us’ page with context using a TemplateView. class AboutUs(TemplateView): template_name = &#39;about-us.html&#39; def get_context_data(self, *args, **kwargs): context = super(AboutUs, self).get_context_data(*args, **kwargs) context[&#39;name&#39;] = &#39;Gryffindor&#39; return context TemplateView has a better separation of defining context variables and defining template name. Essentially a TemplateView helps you avoid boilerplate code like: providing a GET() implementation. creating a returning a HttpResponse() or a subclass of HttpResponse() object.","author":{"@type":"Person","name":"akshar"},"@type":"BlogPosting","url":"http://localhost:4000/django/2017/12/29/when-and-how-use-django-templateview.html","headline":"When and how to use Django TemplateView","dateModified":"2017-12-29T11:30:27+05:30","datePublished":"2017-12-29T11:30:27+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/django/2017/12/29/when-and-how-use-django-templateview.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Agiliq Blogs" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Agiliq Blogs</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/forms.html">Forms</a><a class="page-link" href="/categories/interviews.html">Interviews</a><a class="page-link" href="/categories/marketing.html">Marketing</a><a class="page-link" href="/categories/paypal.html">Paypal</a><a class="page-link" href="/categories/python.html">Python</a><a class="page-link" href="/categories/search.html">Search</a><a class="page-link" href="/categories/startup.html">Startup</a><a class="page-link" href="/categories/uncategorized.html">Uncategorized</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">When and how to use Django TemplateView</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-12-29T11:30:27+05:30" itemprop="datePublished">Dec 29, 2017
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">akshar</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h3 id="when-to-use-template-view">When to use Template View?</h3>

<p>Django provides several class based generic views to accomplish common tasks. Simplest among them is TemplateView.</p>

<p>TemplateView <strong>should be used</strong> when you want to present some information in a html page.</p>

<p>TemplateView <strong>shouldn’t be used</strong> when your page has forms and does creation or update of objects.</p>

<p>TemplateView is most suitable in following cases:</p>

<ul>
  <li>Showing ‘about us’ like pages which are static and hardly needs any context. Though it is easy to use context variables with TemplateView.</li>
  <li>Showing pages which work with GET requests and don’t have forms in it.</li>
</ul>

<p>Let’s write a view using base view <strong>View</strong> and then modify it to use TemplateView. TemplateView would help us avoid several lines of code.</p>

<h4 id="vanilla-view">Vanilla view</h4>

<p>An ‘about us’ page with <strong>View</strong>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from django.views.generic.base import View
from django.shortcuts import render

class AboutUs(View):
	def get(self, request, *args, **kwargs):
		return render(request, "about-us.html")
</code></pre></div></div>

<p>With vanilla View we need to provide a get() implementation and must return a HttpResponse() object from get().</p>

<h4 id="templateview">TemplateView</h4>

<p>The same functionality can be achieved with <strong>TemplateView</strong> in following way:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from django.views.generic.base import TemplateView

class AboutUs(TemplateView):
	template_name = 'about-us.html'
</code></pre></div></div>

<p>As you can notice, we didn’t have to provide a get() implementation while using TemplateView. TemplateView has it’s own get(). TemplateView.get() also encapsulates the creation of HttpResponse object and returning it.</p>

<p>We only had to specify the template_name while using TemplateView.</p>

<p>An ‘about us’ page with <code class="highlighter-rouge">context</code> using a vanilla <strong>View</strong>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class AboutUs(View):
	def get(self, request, *args, **kwargs):
		context = {'name': 'Gryffindor'}
		return render(request, "about-us.html", context=context)
</code></pre></div></div>

<h4 id="templateview-with-context-variables">TemplateView with context variables</h4>

<p>An ‘about us’ page with <code class="highlighter-rouge">context</code> using a <strong>TemplateView</strong>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class AboutUs(TemplateView):
	template_name = 'about-us.html'

	def get_context_data(self, *args, **kwargs):
		context = super(AboutUs, self).get_context_data(*args, **kwargs)
		context['name'] = 'Gryffindor'
		return context
</code></pre></div></div>

<p>TemplateView has a better separation of defining context variables and defining template name.</p>

<p>Essentially a TemplateView helps you avoid boilerplate code like:</p>

<ul>
  <li>providing a GET() implementation.</li>
  <li>creating a returning a HttpResponse() or a subclass of HttpResponse() object.</li>
</ul>


  </div><a class="u-url" href="/django/2017/12/29/when-and-how-use-django-templateview.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Agiliq Blogs</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Agiliq Blogs</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
