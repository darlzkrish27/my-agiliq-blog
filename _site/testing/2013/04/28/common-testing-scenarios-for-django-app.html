<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Common testing scenarios for Django app. | Agiliq Blogs</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Common testing scenarios for Django app." />
<meta name="author" content="akshar" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="People are often confused regarding what tests to write. Let’s look into some scenarios for which tests can be written. ##Setting up the project We start a Django project inside a virtual environment. In this post we would be using django 1.4. (dj)~/play/dj$ django-admin.py startproject testcases Let’s start an app named blog. (dj)~/play/dj/testcases$ python manage.py startapp blog We will have the following model in blog/models.py: class BlogEntry(models.Model): title = models.CharField(max_length=100) text = models.TextField() is_published = models.BooleanField(default=True) user = models.ForeignKey(User) We will do test driven development which requires: Thinking about our assumption. Writing the test to satisfy that assumption. Run the test and it will fail since we won’t have view written till this point. Adding the view. Run the test and fixing the view or anything else till our test passes. If I could not explain the project structure properly, you can find the complete project here. ##First test We want a page which shows all blog entries at url /blog/entries/. We need following line in urls i.e testcases/urls.py url(r&#39;^blog/&#39;, include(&#39;blog.urls&#39;)), blog/urls.py url(r&#39;^entries/$&#39;, &#39;blog.views.entries&#39;, name=&#39;entries&#39;), Let’s add a test which satisfies our assumption. Every app we create gets a tests.py where we can put our tests. You can remove the simple addition test generated by default by Django. blog/tests.py from django.test import TestCase from django.test.client import Client class BlogEntriesTest(TestCase): def setUp(self): self.c = Client() def test_entries_access(self): response = self.c.get(&#39;/blog/entries/&#39;) self.assertEqual(response.status_code, 200) ###Explanation We need a test class which is BlogEntriesTest. Any test class we write must subclass TestCase which is defined in django.test. Actual tests go in methods defined on the test class. So, our test goes in test_entries_access. Every test method name must start with test for it to be found by the django test runner. Before every test, setUp method is run. So anything which is common on all the test methods can go in setUp. We created a Client object in setUp. This object is needed to make GET or POST request. Client object simulates request to a url similar to a browser can. Since it is created in setUp, it will be available in all the test methods. From test_entries_access, we make a GET request to the url which we have defined. We capture the response in variable response. We are asserting that status_code of response must be 200 since we assumed this url to return a 200. ###Running the test Tests use a database. Since sqlite is faster than mysql or postgresql, we would use sqlite as the test database. You can continue using your any other database for development or production. We are only interested in running the tests using sqlite. testcases/test_settings.py from settings import * DATABASES = { &#39;default&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;, &#39;NAME&#39;: &#39;abc&#39; } } Running the test. python manage.py test blog --settings=testcases.test_settings blog says that only run the tests for app blog. Not providing this would run the tests for all the apps defined in INSTALLED_APPS which would take quite some time. Make sure that you have added blog to INSTALLED_APPS. --settings flag tells django test runner to use the specified settings file. And our test fails. ERROR: test_entries_access (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): ...... ...... ViewDoesNotExist: Could not import blog.views.entries. View does not exist in module blog.views. ---------------------------------------------------------------------- Ran 1 test in 0.019s FAILED (errors=1) Because we have not written the view yet. We didn’t have to go to browser to check if this url works, our test does it for us. We should test every url we want available in our project. So, that if some url breaks our test would tell that to us immediately. ###Adding the view from blog.models import BlogEntry from django.shortcuts import render def entries(request): entries = BlogEntry.objects.all() return render(&quot;blog/entries.html&quot;, {&#39;entries&#39;: entries}) Make sure to add the template blog/entries.html in your template directory. Run the test again. python manage.py test blog --settings=testcases.test_settings Ran 1 test in 0.019s OK Destroying test database for alias &#39;default&#39;... ###Minor modification to test Since we should not hardcode the urls, we will use reverse. def test_entries_access(self): response = self.c.get(reverse(&#39;entries&#39;)) self.assertEqual(response.status_code, 200) Run the test again to make sure our change has not broken anything. ##Test that context is populated in template We want to make sure that our expectation regarding number of visible blog entries on the page matches the result. Say we have two entries in the database then both of them should be shown on the page as per our view definition. A blog must be associated with a user. So, we will create an instance of user in setUp because we would need this user in other tests as well. def setUp(self): self.c = Client() self.user = User.objects.create_user(username=&quot;test&quot;, email=&quot;test@test.com&quot;, password=&quot;test&quot;) ###Testing the context def test_entries_template_context(self): #create few blog entries BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) response = self.c.get(reverse(&#39;entries&#39;)) #assert that context contains as many entries as you expect self.assertEqual(len(response.context[&#39;entries&#39;]), 2) response contains an attribute context which is a dictionary containing the context sent to template. ###Assertion We created two blogs and asserted that context contains both of them. This test is not much useful now. We will see how response.context becomes useful when we write a custom manager. ##Only logged in user must access create entry page. def test_entry_create(self): response = self.c.get(reverse(&#39;entry_create&#39;)) self.assertEqual(response.status_code, 302) self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) response = self.c.get(reverse(&#39;entry_create&#39;)) self.assertEqual(response.status_code, 200) Run the test. We know it will fail because we have not written the view or the url yet. python manage.py test blog --settings=testcases.test_settings ..... ERROR: test_entry_create (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): .... NoReverseMatch: Reverse for &#39;entry_create&#39; with arguments &#39;()&#39; and keyword arguments &#39;{}&#39; not found. ---------------------------------------------------------------------- Ran 3 tests in 0.051s FAILED (errors=1) ###Explanation: We expect a url with name entry_create to be available. A non-logged user should not be able to access this url and should be redirected to login urll. So, we assert that status code be 302. There is a login method defined on Client. So, we can call self.c.login(). login() takes a username and password. You should provide credentials of some user already present in db. Remember we created an user in setUp. We pass the same credentials here. After this client i.e self.c starts behaving like a logged in user. Now client should be able to access create page and so we assert the status code as 200. Let’s start fixing this test. Need to add following in blog/urls.py url(r&#39;^entry/create/$&#39;, &#39;blog.views.entry_create&#39;, name=&#39;entry_create&#39;), Adding a modelform. This will be used in create view. class BlogEntryForm(ModelForm): class Meta: model = BlogEntry Adding the view def entry_create(request): form = BlogEntryForm() if request.method == &quot;POST&quot;: form = BlogEntryForm(request.POST) if form.is_valid(): return HttpResponseRedirect(reverse(&#39;entries&#39;)) form.save() return render(request, &quot;blog/entry_create.html&quot;, {&#39;form&#39;: form}) Make sure to create the template. And then run the test. You will still see an error. File &quot;/home/akshar/play/dj/testcases/blog/tests.py&quot;, line 30, in test_entry_create self.assertEqual(response.status_code, 302) AssertionError: 200 != 302 Because we missed adding login_required to the view and even anonymous users are able to access this url. And hence they are getting a 200 instead of 302. Let’s fix it by adding login_required decorator to entry_create view. Run the test again and it should pass now. ##Test invalid form So, we wrote entry_create with assumption that it will handle POST requests. We want to make sure that this view doesn’t allow invalid POST and raises an exception in that case. def test_invalid_entry_create(self): self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) data = {&#39;text&#39;: &#39;Test text&#39;} response = self.c.post(reverse(&#39;entry_create&#39;), data) self.assertEqual(response.status_code, 200) self.assertFormError(response, &quot;form&quot;, &quot;title&quot;, &quot;This field is required.&quot;) ###Assertions: Since we posted an invalid form, we expect to remain on the same page. So asserted for status code of 200. We expect an error to be present on the title field. ##Test valid form def test_valid_entry_create(self): self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) data = {&#39;text&#39;: &#39;Test text&#39;, &#39;title&#39;: &#39;Test title&#39;} data[&#39;user&#39;] = self.user.id self.assertEqual(BlogEntry.objects.count(), 0) response = self.c.post(reverse(&#39;entry_create&#39;), data) self.assertEqual(response.status_code, 302) self.assertEqual(BlogEntry.objects.count(), 1) ###Assertions: Before posting we assert that there is no BlogEntry in the db. After posting we check that the user is redirected and so asserted for status code of 302 We make sure that a BlogEntry is created in the database on post by checking that count of BlogEntry has been increased to 1. ##Test custom manager methods Suppose you find yourself writing the same filter multiple times for getting the blog entries which have is_published as True. In that case you would write a custom manager. We will add the custom manager in models.py class PublishedBlogManager(models.Manager): def get_query_set(self, *args, **kwargs): return super(PublishedBlogManager, self).get_query_set(*args, **kwargs).filter(is_published=True) Also we need to add this manager on BlogEntry. So, don’t forget to add next two lines to BlogEntry objects = models.Manager() published = PublishedBlogManager() Let’s write a test now: def test_entry_custom_managers(self): BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user, is_published=False) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) self.assertEqual(BlogEntry.objects.count(), 2) self.assertEqual(BlogEntry.published.count(), 1) ###Assertions: We created two entries. One with is_published as False, and another with True. objects i.e default manager returns all the entries. published i.e custom manager returns only entries which have is_published=True. ###Using custom manager in test_entries_template_context: Say now we decide that all entries should not be shown on list entries page. Only published entries should be shown. Remember test_entries_template_context. We only created two blog entries in that test. Edit that test and create one more entry with is_published=False def test_entries_template_context(self): #create few blog entries BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user, is_published=False) response = self.c.get(reverse(&#39;entries&#39;)) #assert that context contains only published entries self.assertEqual(len(response.context[&#39;entries&#39;]), 2) We created three entries. Only two of them are published. ###Assertion: Entries page should only show 2 entries. Run the test and it will fail. ====================================================================== FAIL: test_entries_template_context (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;/home/akshar/play/dj/testcases/blog/tests.py&quot;, line 29, in test_entries_template_context self.assertEqual(len(response.context[&#39;entries&#39;]), 2) AssertionError: 3 != 2 ---------------------------------------------------------------------- Happened because we forgot to change our view. Our view still says BlogEntry.objects.all(). We should change it to BlogEntry.published.all(). Make this change and the test will pass. def entries(request): entries = BlogEntry.published.all() return render_to_response(&quot;blog/entries.html&quot;, {&#39;entries&#39;: entries}) So, response.context helped us find that we do not show more entries than we should. ##Test for pagination Suppose we expect maximum ten entries to be available on each page. There are 15 entries in the db, so first page should show 10 entries and the second page should show 5. If user tries to access the third page a 404 page should be shown. Our decided url pattern for getting entries on a particular page: url(r&#39;^entries/(?P&lt;page&gt;\d+)/$&#39;, &#39;blog.views.entries_page&#39;, name=&#39;entries_page&#39;) Writing the test: def test_entries_page(self): for i in range(15): BlogEntry.objects.create(title=&quot;title&quot;, text=&quot;text&quot;, user=self.user, is_published=True) #access first page response = self.c.get(reverse(&quot;entries_page&quot;, args=[1,])) self.assertEqual(response.status_code, 200) self.assertEqual(len(response.context[&#39;entries&#39;]), 10) #access second page response = self.c.get(reverse(&quot;entries_page&quot;, args=[2,])) self.assertEqual(response.status_code, 200) self.assertEqual(len(response.context[&#39;entries&#39;]), 5) Run the test and it will fail. Let’s add view to make it pass. def entries_page(request, page): page = int(page) entries = BlogEntry.published.all() paginator = Paginator(entries, 10) #10 entries per page page_ = paginator.page(page) object_list = page_.object_list return render(request, &quot;blog/entries_page.html&quot;, {&quot;entries&quot;: object_list}) Test should pass now provided you have added the template. Let’s try to access third page in the test. We need to add following in test_entries_page for that. #access third page response = self.c.get(reverse(&quot;entries_page&quot;, args=[3,])) self.assertEqual(response.status_code, 404) Running the test raises an error. .... raise EmptyPage(&#39;That page contains no results&#39;) EmptyPage: That page contains no results We find that there is a bug in our view and any page which doesn’t contain entries is not being handled as we want. Let’s change our view: def entries_page(request, page): page = int(page) entries = BlogEntry.published.all() paginator = Paginator(entries, 10) #10 entries per page if page &gt; paginator.num_pages: raise Http404() page_ = paginator.page(page) object_list = page_.object_list return render(request, &quot;blog/entries_page.html&quot;, {&quot;entries&quot;: object_list}) Run the test again. If you have a 404 template defined then your test will pass. In this project we do not have a 404 template and so we get another exception ERROR: test_entries_page (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): .... raise TemplateDoesNotExist(name) TemplateDoesNotExist: 404.html So, let’s add a 404 template. Test passes once we do it. So, this test also helped us find a missing 404 template. ##Test for static files You can look at our blog on static file if you have some confusion regarding how static files are served in Django. We will create a static directory in our app blog and will put an image in this directory. Let’s say this image is default.jpg Let’s add a test to make sure this image is found by django static file handlers. This test makes us confident that we can expect this image to be served at default.jpg from django.contrib.staticfiles import finders from django.contrib.staticfiles.storage import staticfiles_storage def test_images(self): abs_path = finders.find(&#39;default.jpg&#39;) self.assertTrue(staticfiles_storage.exists(abs_path)) Run the test and it should pass. You can view the complete project here." />
<meta property="og:description" content="People are often confused regarding what tests to write. Let’s look into some scenarios for which tests can be written. ##Setting up the project We start a Django project inside a virtual environment. In this post we would be using django 1.4. (dj)~/play/dj$ django-admin.py startproject testcases Let’s start an app named blog. (dj)~/play/dj/testcases$ python manage.py startapp blog We will have the following model in blog/models.py: class BlogEntry(models.Model): title = models.CharField(max_length=100) text = models.TextField() is_published = models.BooleanField(default=True) user = models.ForeignKey(User) We will do test driven development which requires: Thinking about our assumption. Writing the test to satisfy that assumption. Run the test and it will fail since we won’t have view written till this point. Adding the view. Run the test and fixing the view or anything else till our test passes. If I could not explain the project structure properly, you can find the complete project here. ##First test We want a page which shows all blog entries at url /blog/entries/. We need following line in urls i.e testcases/urls.py url(r&#39;^blog/&#39;, include(&#39;blog.urls&#39;)), blog/urls.py url(r&#39;^entries/$&#39;, &#39;blog.views.entries&#39;, name=&#39;entries&#39;), Let’s add a test which satisfies our assumption. Every app we create gets a tests.py where we can put our tests. You can remove the simple addition test generated by default by Django. blog/tests.py from django.test import TestCase from django.test.client import Client class BlogEntriesTest(TestCase): def setUp(self): self.c = Client() def test_entries_access(self): response = self.c.get(&#39;/blog/entries/&#39;) self.assertEqual(response.status_code, 200) ###Explanation We need a test class which is BlogEntriesTest. Any test class we write must subclass TestCase which is defined in django.test. Actual tests go in methods defined on the test class. So, our test goes in test_entries_access. Every test method name must start with test for it to be found by the django test runner. Before every test, setUp method is run. So anything which is common on all the test methods can go in setUp. We created a Client object in setUp. This object is needed to make GET or POST request. Client object simulates request to a url similar to a browser can. Since it is created in setUp, it will be available in all the test methods. From test_entries_access, we make a GET request to the url which we have defined. We capture the response in variable response. We are asserting that status_code of response must be 200 since we assumed this url to return a 200. ###Running the test Tests use a database. Since sqlite is faster than mysql or postgresql, we would use sqlite as the test database. You can continue using your any other database for development or production. We are only interested in running the tests using sqlite. testcases/test_settings.py from settings import * DATABASES = { &#39;default&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;, &#39;NAME&#39;: &#39;abc&#39; } } Running the test. python manage.py test blog --settings=testcases.test_settings blog says that only run the tests for app blog. Not providing this would run the tests for all the apps defined in INSTALLED_APPS which would take quite some time. Make sure that you have added blog to INSTALLED_APPS. --settings flag tells django test runner to use the specified settings file. And our test fails. ERROR: test_entries_access (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): ...... ...... ViewDoesNotExist: Could not import blog.views.entries. View does not exist in module blog.views. ---------------------------------------------------------------------- Ran 1 test in 0.019s FAILED (errors=1) Because we have not written the view yet. We didn’t have to go to browser to check if this url works, our test does it for us. We should test every url we want available in our project. So, that if some url breaks our test would tell that to us immediately. ###Adding the view from blog.models import BlogEntry from django.shortcuts import render def entries(request): entries = BlogEntry.objects.all() return render(&quot;blog/entries.html&quot;, {&#39;entries&#39;: entries}) Make sure to add the template blog/entries.html in your template directory. Run the test again. python manage.py test blog --settings=testcases.test_settings Ran 1 test in 0.019s OK Destroying test database for alias &#39;default&#39;... ###Minor modification to test Since we should not hardcode the urls, we will use reverse. def test_entries_access(self): response = self.c.get(reverse(&#39;entries&#39;)) self.assertEqual(response.status_code, 200) Run the test again to make sure our change has not broken anything. ##Test that context is populated in template We want to make sure that our expectation regarding number of visible blog entries on the page matches the result. Say we have two entries in the database then both of them should be shown on the page as per our view definition. A blog must be associated with a user. So, we will create an instance of user in setUp because we would need this user in other tests as well. def setUp(self): self.c = Client() self.user = User.objects.create_user(username=&quot;test&quot;, email=&quot;test@test.com&quot;, password=&quot;test&quot;) ###Testing the context def test_entries_template_context(self): #create few blog entries BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) response = self.c.get(reverse(&#39;entries&#39;)) #assert that context contains as many entries as you expect self.assertEqual(len(response.context[&#39;entries&#39;]), 2) response contains an attribute context which is a dictionary containing the context sent to template. ###Assertion We created two blogs and asserted that context contains both of them. This test is not much useful now. We will see how response.context becomes useful when we write a custom manager. ##Only logged in user must access create entry page. def test_entry_create(self): response = self.c.get(reverse(&#39;entry_create&#39;)) self.assertEqual(response.status_code, 302) self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) response = self.c.get(reverse(&#39;entry_create&#39;)) self.assertEqual(response.status_code, 200) Run the test. We know it will fail because we have not written the view or the url yet. python manage.py test blog --settings=testcases.test_settings ..... ERROR: test_entry_create (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): .... NoReverseMatch: Reverse for &#39;entry_create&#39; with arguments &#39;()&#39; and keyword arguments &#39;{}&#39; not found. ---------------------------------------------------------------------- Ran 3 tests in 0.051s FAILED (errors=1) ###Explanation: We expect a url with name entry_create to be available. A non-logged user should not be able to access this url and should be redirected to login urll. So, we assert that status code be 302. There is a login method defined on Client. So, we can call self.c.login(). login() takes a username and password. You should provide credentials of some user already present in db. Remember we created an user in setUp. We pass the same credentials here. After this client i.e self.c starts behaving like a logged in user. Now client should be able to access create page and so we assert the status code as 200. Let’s start fixing this test. Need to add following in blog/urls.py url(r&#39;^entry/create/$&#39;, &#39;blog.views.entry_create&#39;, name=&#39;entry_create&#39;), Adding a modelform. This will be used in create view. class BlogEntryForm(ModelForm): class Meta: model = BlogEntry Adding the view def entry_create(request): form = BlogEntryForm() if request.method == &quot;POST&quot;: form = BlogEntryForm(request.POST) if form.is_valid(): return HttpResponseRedirect(reverse(&#39;entries&#39;)) form.save() return render(request, &quot;blog/entry_create.html&quot;, {&#39;form&#39;: form}) Make sure to create the template. And then run the test. You will still see an error. File &quot;/home/akshar/play/dj/testcases/blog/tests.py&quot;, line 30, in test_entry_create self.assertEqual(response.status_code, 302) AssertionError: 200 != 302 Because we missed adding login_required to the view and even anonymous users are able to access this url. And hence they are getting a 200 instead of 302. Let’s fix it by adding login_required decorator to entry_create view. Run the test again and it should pass now. ##Test invalid form So, we wrote entry_create with assumption that it will handle POST requests. We want to make sure that this view doesn’t allow invalid POST and raises an exception in that case. def test_invalid_entry_create(self): self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) data = {&#39;text&#39;: &#39;Test text&#39;} response = self.c.post(reverse(&#39;entry_create&#39;), data) self.assertEqual(response.status_code, 200) self.assertFormError(response, &quot;form&quot;, &quot;title&quot;, &quot;This field is required.&quot;) ###Assertions: Since we posted an invalid form, we expect to remain on the same page. So asserted for status code of 200. We expect an error to be present on the title field. ##Test valid form def test_valid_entry_create(self): self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) data = {&#39;text&#39;: &#39;Test text&#39;, &#39;title&#39;: &#39;Test title&#39;} data[&#39;user&#39;] = self.user.id self.assertEqual(BlogEntry.objects.count(), 0) response = self.c.post(reverse(&#39;entry_create&#39;), data) self.assertEqual(response.status_code, 302) self.assertEqual(BlogEntry.objects.count(), 1) ###Assertions: Before posting we assert that there is no BlogEntry in the db. After posting we check that the user is redirected and so asserted for status code of 302 We make sure that a BlogEntry is created in the database on post by checking that count of BlogEntry has been increased to 1. ##Test custom manager methods Suppose you find yourself writing the same filter multiple times for getting the blog entries which have is_published as True. In that case you would write a custom manager. We will add the custom manager in models.py class PublishedBlogManager(models.Manager): def get_query_set(self, *args, **kwargs): return super(PublishedBlogManager, self).get_query_set(*args, **kwargs).filter(is_published=True) Also we need to add this manager on BlogEntry. So, don’t forget to add next two lines to BlogEntry objects = models.Manager() published = PublishedBlogManager() Let’s write a test now: def test_entry_custom_managers(self): BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user, is_published=False) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) self.assertEqual(BlogEntry.objects.count(), 2) self.assertEqual(BlogEntry.published.count(), 1) ###Assertions: We created two entries. One with is_published as False, and another with True. objects i.e default manager returns all the entries. published i.e custom manager returns only entries which have is_published=True. ###Using custom manager in test_entries_template_context: Say now we decide that all entries should not be shown on list entries page. Only published entries should be shown. Remember test_entries_template_context. We only created two blog entries in that test. Edit that test and create one more entry with is_published=False def test_entries_template_context(self): #create few blog entries BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user, is_published=False) response = self.c.get(reverse(&#39;entries&#39;)) #assert that context contains only published entries self.assertEqual(len(response.context[&#39;entries&#39;]), 2) We created three entries. Only two of them are published. ###Assertion: Entries page should only show 2 entries. Run the test and it will fail. ====================================================================== FAIL: test_entries_template_context (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;/home/akshar/play/dj/testcases/blog/tests.py&quot;, line 29, in test_entries_template_context self.assertEqual(len(response.context[&#39;entries&#39;]), 2) AssertionError: 3 != 2 ---------------------------------------------------------------------- Happened because we forgot to change our view. Our view still says BlogEntry.objects.all(). We should change it to BlogEntry.published.all(). Make this change and the test will pass. def entries(request): entries = BlogEntry.published.all() return render_to_response(&quot;blog/entries.html&quot;, {&#39;entries&#39;: entries}) So, response.context helped us find that we do not show more entries than we should. ##Test for pagination Suppose we expect maximum ten entries to be available on each page. There are 15 entries in the db, so first page should show 10 entries and the second page should show 5. If user tries to access the third page a 404 page should be shown. Our decided url pattern for getting entries on a particular page: url(r&#39;^entries/(?P&lt;page&gt;\d+)/$&#39;, &#39;blog.views.entries_page&#39;, name=&#39;entries_page&#39;) Writing the test: def test_entries_page(self): for i in range(15): BlogEntry.objects.create(title=&quot;title&quot;, text=&quot;text&quot;, user=self.user, is_published=True) #access first page response = self.c.get(reverse(&quot;entries_page&quot;, args=[1,])) self.assertEqual(response.status_code, 200) self.assertEqual(len(response.context[&#39;entries&#39;]), 10) #access second page response = self.c.get(reverse(&quot;entries_page&quot;, args=[2,])) self.assertEqual(response.status_code, 200) self.assertEqual(len(response.context[&#39;entries&#39;]), 5) Run the test and it will fail. Let’s add view to make it pass. def entries_page(request, page): page = int(page) entries = BlogEntry.published.all() paginator = Paginator(entries, 10) #10 entries per page page_ = paginator.page(page) object_list = page_.object_list return render(request, &quot;blog/entries_page.html&quot;, {&quot;entries&quot;: object_list}) Test should pass now provided you have added the template. Let’s try to access third page in the test. We need to add following in test_entries_page for that. #access third page response = self.c.get(reverse(&quot;entries_page&quot;, args=[3,])) self.assertEqual(response.status_code, 404) Running the test raises an error. .... raise EmptyPage(&#39;That page contains no results&#39;) EmptyPage: That page contains no results We find that there is a bug in our view and any page which doesn’t contain entries is not being handled as we want. Let’s change our view: def entries_page(request, page): page = int(page) entries = BlogEntry.published.all() paginator = Paginator(entries, 10) #10 entries per page if page &gt; paginator.num_pages: raise Http404() page_ = paginator.page(page) object_list = page_.object_list return render(request, &quot;blog/entries_page.html&quot;, {&quot;entries&quot;: object_list}) Run the test again. If you have a 404 template defined then your test will pass. In this project we do not have a 404 template and so we get another exception ERROR: test_entries_page (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): .... raise TemplateDoesNotExist(name) TemplateDoesNotExist: 404.html So, let’s add a 404 template. Test passes once we do it. So, this test also helped us find a missing 404 template. ##Test for static files You can look at our blog on static file if you have some confusion regarding how static files are served in Django. We will create a static directory in our app blog and will put an image in this directory. Let’s say this image is default.jpg Let’s add a test to make sure this image is found by django static file handlers. This test makes us confident that we can expect this image to be served at default.jpg from django.contrib.staticfiles import finders from django.contrib.staticfiles.storage import staticfiles_storage def test_images(self): abs_path = finders.find(&#39;default.jpg&#39;) self.assertTrue(staticfiles_storage.exists(abs_path)) Run the test and it should pass. You can view the complete project here." />
<link rel="canonical" href="http://localhost:4000/testing/2013/04/28/common-testing-scenarios-for-django-app.html" />
<meta property="og:url" content="http://localhost:4000/testing/2013/04/28/common-testing-scenarios-for-django-app.html" />
<meta property="og:site_name" content="Agiliq Blogs" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-04-28T20:33:38+05:30" />
<script type="application/ld+json">
{"description":"People are often confused regarding what tests to write. Let’s look into some scenarios for which tests can be written. ##Setting up the project We start a Django project inside a virtual environment. In this post we would be using django 1.4. (dj)~/play/dj$ django-admin.py startproject testcases Let’s start an app named blog. (dj)~/play/dj/testcases$ python manage.py startapp blog We will have the following model in blog/models.py: class BlogEntry(models.Model): title = models.CharField(max_length=100) text = models.TextField() is_published = models.BooleanField(default=True) user = models.ForeignKey(User) We will do test driven development which requires: Thinking about our assumption. Writing the test to satisfy that assumption. Run the test and it will fail since we won’t have view written till this point. Adding the view. Run the test and fixing the view or anything else till our test passes. If I could not explain the project structure properly, you can find the complete project here. ##First test We want a page which shows all blog entries at url /blog/entries/. We need following line in urls i.e testcases/urls.py url(r&#39;^blog/&#39;, include(&#39;blog.urls&#39;)), blog/urls.py url(r&#39;^entries/$&#39;, &#39;blog.views.entries&#39;, name=&#39;entries&#39;), Let’s add a test which satisfies our assumption. Every app we create gets a tests.py where we can put our tests. You can remove the simple addition test generated by default by Django. blog/tests.py from django.test import TestCase from django.test.client import Client class BlogEntriesTest(TestCase): def setUp(self): self.c = Client() def test_entries_access(self): response = self.c.get(&#39;/blog/entries/&#39;) self.assertEqual(response.status_code, 200) ###Explanation We need a test class which is BlogEntriesTest. Any test class we write must subclass TestCase which is defined in django.test. Actual tests go in methods defined on the test class. So, our test goes in test_entries_access. Every test method name must start with test for it to be found by the django test runner. Before every test, setUp method is run. So anything which is common on all the test methods can go in setUp. We created a Client object in setUp. This object is needed to make GET or POST request. Client object simulates request to a url similar to a browser can. Since it is created in setUp, it will be available in all the test methods. From test_entries_access, we make a GET request to the url which we have defined. We capture the response in variable response. We are asserting that status_code of response must be 200 since we assumed this url to return a 200. ###Running the test Tests use a database. Since sqlite is faster than mysql or postgresql, we would use sqlite as the test database. You can continue using your any other database for development or production. We are only interested in running the tests using sqlite. testcases/test_settings.py from settings import * DATABASES = { &#39;default&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;, &#39;NAME&#39;: &#39;abc&#39; } } Running the test. python manage.py test blog --settings=testcases.test_settings blog says that only run the tests for app blog. Not providing this would run the tests for all the apps defined in INSTALLED_APPS which would take quite some time. Make sure that you have added blog to INSTALLED_APPS. --settings flag tells django test runner to use the specified settings file. And our test fails. ERROR: test_entries_access (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): ...... ...... ViewDoesNotExist: Could not import blog.views.entries. View does not exist in module blog.views. ---------------------------------------------------------------------- Ran 1 test in 0.019s FAILED (errors=1) Because we have not written the view yet. We didn’t have to go to browser to check if this url works, our test does it for us. We should test every url we want available in our project. So, that if some url breaks our test would tell that to us immediately. ###Adding the view from blog.models import BlogEntry from django.shortcuts import render def entries(request): entries = BlogEntry.objects.all() return render(&quot;blog/entries.html&quot;, {&#39;entries&#39;: entries}) Make sure to add the template blog/entries.html in your template directory. Run the test again. python manage.py test blog --settings=testcases.test_settings Ran 1 test in 0.019s OK Destroying test database for alias &#39;default&#39;... ###Minor modification to test Since we should not hardcode the urls, we will use reverse. def test_entries_access(self): response = self.c.get(reverse(&#39;entries&#39;)) self.assertEqual(response.status_code, 200) Run the test again to make sure our change has not broken anything. ##Test that context is populated in template We want to make sure that our expectation regarding number of visible blog entries on the page matches the result. Say we have two entries in the database then both of them should be shown on the page as per our view definition. A blog must be associated with a user. So, we will create an instance of user in setUp because we would need this user in other tests as well. def setUp(self): self.c = Client() self.user = User.objects.create_user(username=&quot;test&quot;, email=&quot;test@test.com&quot;, password=&quot;test&quot;) ###Testing the context def test_entries_template_context(self): #create few blog entries BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) response = self.c.get(reverse(&#39;entries&#39;)) #assert that context contains as many entries as you expect self.assertEqual(len(response.context[&#39;entries&#39;]), 2) response contains an attribute context which is a dictionary containing the context sent to template. ###Assertion We created two blogs and asserted that context contains both of them. This test is not much useful now. We will see how response.context becomes useful when we write a custom manager. ##Only logged in user must access create entry page. def test_entry_create(self): response = self.c.get(reverse(&#39;entry_create&#39;)) self.assertEqual(response.status_code, 302) self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) response = self.c.get(reverse(&#39;entry_create&#39;)) self.assertEqual(response.status_code, 200) Run the test. We know it will fail because we have not written the view or the url yet. python manage.py test blog --settings=testcases.test_settings ..... ERROR: test_entry_create (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): .... NoReverseMatch: Reverse for &#39;entry_create&#39; with arguments &#39;()&#39; and keyword arguments &#39;{}&#39; not found. ---------------------------------------------------------------------- Ran 3 tests in 0.051s FAILED (errors=1) ###Explanation: We expect a url with name entry_create to be available. A non-logged user should not be able to access this url and should be redirected to login urll. So, we assert that status code be 302. There is a login method defined on Client. So, we can call self.c.login(). login() takes a username and password. You should provide credentials of some user already present in db. Remember we created an user in setUp. We pass the same credentials here. After this client i.e self.c starts behaving like a logged in user. Now client should be able to access create page and so we assert the status code as 200. Let’s start fixing this test. Need to add following in blog/urls.py url(r&#39;^entry/create/$&#39;, &#39;blog.views.entry_create&#39;, name=&#39;entry_create&#39;), Adding a modelform. This will be used in create view. class BlogEntryForm(ModelForm): class Meta: model = BlogEntry Adding the view def entry_create(request): form = BlogEntryForm() if request.method == &quot;POST&quot;: form = BlogEntryForm(request.POST) if form.is_valid(): return HttpResponseRedirect(reverse(&#39;entries&#39;)) form.save() return render(request, &quot;blog/entry_create.html&quot;, {&#39;form&#39;: form}) Make sure to create the template. And then run the test. You will still see an error. File &quot;/home/akshar/play/dj/testcases/blog/tests.py&quot;, line 30, in test_entry_create self.assertEqual(response.status_code, 302) AssertionError: 200 != 302 Because we missed adding login_required to the view and even anonymous users are able to access this url. And hence they are getting a 200 instead of 302. Let’s fix it by adding login_required decorator to entry_create view. Run the test again and it should pass now. ##Test invalid form So, we wrote entry_create with assumption that it will handle POST requests. We want to make sure that this view doesn’t allow invalid POST and raises an exception in that case. def test_invalid_entry_create(self): self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) data = {&#39;text&#39;: &#39;Test text&#39;} response = self.c.post(reverse(&#39;entry_create&#39;), data) self.assertEqual(response.status_code, 200) self.assertFormError(response, &quot;form&quot;, &quot;title&quot;, &quot;This field is required.&quot;) ###Assertions: Since we posted an invalid form, we expect to remain on the same page. So asserted for status code of 200. We expect an error to be present on the title field. ##Test valid form def test_valid_entry_create(self): self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) data = {&#39;text&#39;: &#39;Test text&#39;, &#39;title&#39;: &#39;Test title&#39;} data[&#39;user&#39;] = self.user.id self.assertEqual(BlogEntry.objects.count(), 0) response = self.c.post(reverse(&#39;entry_create&#39;), data) self.assertEqual(response.status_code, 302) self.assertEqual(BlogEntry.objects.count(), 1) ###Assertions: Before posting we assert that there is no BlogEntry in the db. After posting we check that the user is redirected and so asserted for status code of 302 We make sure that a BlogEntry is created in the database on post by checking that count of BlogEntry has been increased to 1. ##Test custom manager methods Suppose you find yourself writing the same filter multiple times for getting the blog entries which have is_published as True. In that case you would write a custom manager. We will add the custom manager in models.py class PublishedBlogManager(models.Manager): def get_query_set(self, *args, **kwargs): return super(PublishedBlogManager, self).get_query_set(*args, **kwargs).filter(is_published=True) Also we need to add this manager on BlogEntry. So, don’t forget to add next two lines to BlogEntry objects = models.Manager() published = PublishedBlogManager() Let’s write a test now: def test_entry_custom_managers(self): BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user, is_published=False) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) self.assertEqual(BlogEntry.objects.count(), 2) self.assertEqual(BlogEntry.published.count(), 1) ###Assertions: We created two entries. One with is_published as False, and another with True. objects i.e default manager returns all the entries. published i.e custom manager returns only entries which have is_published=True. ###Using custom manager in test_entries_template_context: Say now we decide that all entries should not be shown on list entries page. Only published entries should be shown. Remember test_entries_template_context. We only created two blog entries in that test. Edit that test and create one more entry with is_published=False def test_entries_template_context(self): #create few blog entries BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user, is_published=False) response = self.c.get(reverse(&#39;entries&#39;)) #assert that context contains only published entries self.assertEqual(len(response.context[&#39;entries&#39;]), 2) We created three entries. Only two of them are published. ###Assertion: Entries page should only show 2 entries. Run the test and it will fail. ====================================================================== FAIL: test_entries_template_context (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;/home/akshar/play/dj/testcases/blog/tests.py&quot;, line 29, in test_entries_template_context self.assertEqual(len(response.context[&#39;entries&#39;]), 2) AssertionError: 3 != 2 ---------------------------------------------------------------------- Happened because we forgot to change our view. Our view still says BlogEntry.objects.all(). We should change it to BlogEntry.published.all(). Make this change and the test will pass. def entries(request): entries = BlogEntry.published.all() return render_to_response(&quot;blog/entries.html&quot;, {&#39;entries&#39;: entries}) So, response.context helped us find that we do not show more entries than we should. ##Test for pagination Suppose we expect maximum ten entries to be available on each page. There are 15 entries in the db, so first page should show 10 entries and the second page should show 5. If user tries to access the third page a 404 page should be shown. Our decided url pattern for getting entries on a particular page: url(r&#39;^entries/(?P&lt;page&gt;\\d+)/$&#39;, &#39;blog.views.entries_page&#39;, name=&#39;entries_page&#39;) Writing the test: def test_entries_page(self): for i in range(15): BlogEntry.objects.create(title=&quot;title&quot;, text=&quot;text&quot;, user=self.user, is_published=True) #access first page response = self.c.get(reverse(&quot;entries_page&quot;, args=[1,])) self.assertEqual(response.status_code, 200) self.assertEqual(len(response.context[&#39;entries&#39;]), 10) #access second page response = self.c.get(reverse(&quot;entries_page&quot;, args=[2,])) self.assertEqual(response.status_code, 200) self.assertEqual(len(response.context[&#39;entries&#39;]), 5) Run the test and it will fail. Let’s add view to make it pass. def entries_page(request, page): page = int(page) entries = BlogEntry.published.all() paginator = Paginator(entries, 10) #10 entries per page page_ = paginator.page(page) object_list = page_.object_list return render(request, &quot;blog/entries_page.html&quot;, {&quot;entries&quot;: object_list}) Test should pass now provided you have added the template. Let’s try to access third page in the test. We need to add following in test_entries_page for that. #access third page response = self.c.get(reverse(&quot;entries_page&quot;, args=[3,])) self.assertEqual(response.status_code, 404) Running the test raises an error. .... raise EmptyPage(&#39;That page contains no results&#39;) EmptyPage: That page contains no results We find that there is a bug in our view and any page which doesn’t contain entries is not being handled as we want. Let’s change our view: def entries_page(request, page): page = int(page) entries = BlogEntry.published.all() paginator = Paginator(entries, 10) #10 entries per page if page &gt; paginator.num_pages: raise Http404() page_ = paginator.page(page) object_list = page_.object_list return render(request, &quot;blog/entries_page.html&quot;, {&quot;entries&quot;: object_list}) Run the test again. If you have a 404 template defined then your test will pass. In this project we do not have a 404 template and so we get another exception ERROR: test_entries_page (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): .... raise TemplateDoesNotExist(name) TemplateDoesNotExist: 404.html So, let’s add a 404 template. Test passes once we do it. So, this test also helped us find a missing 404 template. ##Test for static files You can look at our blog on static file if you have some confusion regarding how static files are served in Django. We will create a static directory in our app blog and will put an image in this directory. Let’s say this image is default.jpg Let’s add a test to make sure this image is found by django static file handlers. This test makes us confident that we can expect this image to be served at default.jpg from django.contrib.staticfiles import finders from django.contrib.staticfiles.storage import staticfiles_storage def test_images(self): abs_path = finders.find(&#39;default.jpg&#39;) self.assertTrue(staticfiles_storage.exists(abs_path)) Run the test and it should pass. You can view the complete project here.","author":{"@type":"Person","name":"akshar"},"@type":"BlogPosting","url":"http://localhost:4000/testing/2013/04/28/common-testing-scenarios-for-django-app.html","headline":"Common testing scenarios for Django app.","dateModified":"2013-04-28T20:33:38+05:30","datePublished":"2013-04-28T20:33:38+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/testing/2013/04/28/common-testing-scenarios-for-django-app.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Agiliq Blogs" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Agiliq Blogs</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/forms.html">Forms</a><a class="page-link" href="/categories/interviews.html">Interviews</a><a class="page-link" href="/categories/marketing.html">Marketing</a><a class="page-link" href="/categories/paypal.html">Paypal</a><a class="page-link" href="/categories/python.html">Python</a><a class="page-link" href="/categories/search.html">Search</a><a class="page-link" href="/categories/startup.html">Startup</a><a class="page-link" href="/categories/uncategorized.html">Uncategorized</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Common testing scenarios for Django app.</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2013-04-28T20:33:38+05:30" itemprop="datePublished">Apr 28, 2013
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">akshar</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>People are often confused regarding what tests to write. Let’s look into some scenarios for which tests can be written.</p>

<p>##Setting up the project</p>

<p>We start a Django project inside a virtual environment. In this post we would be using django 1.4.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(dj)~/play/dj$ django-admin.py startproject testcases
</code></pre></div></div>

<p>Let’s start an app named <code class="highlighter-rouge">blog</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(dj)~/play/dj/testcases$ python manage.py startapp blog
</code></pre></div></div>

<p>We will have the following model in <code class="highlighter-rouge">blog/models.py</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class BlogEntry(models.Model):
    title = models.CharField(max_length=100)
    text = models.TextField()
    is_published = models.BooleanField(default=True)
    user = models.ForeignKey(User)
</code></pre></div></div>

<p>We will do test driven development which requires:</p>

<ul>
  <li>Thinking about our assumption.</li>
  <li>Writing the test to satisfy that assumption.</li>
  <li>Run the test and it will fail since we won’t have view written till this point.</li>
  <li>Adding the view.</li>
  <li>Run the test and fixing the view or anything else till our test passes.</li>
</ul>

<p>If I could not explain the project structure properly, you can find the complete project <a href="https://github.com/akshar-raaj/Testing-in-Django">here</a>.</p>

<p>##First test</p>

<p>We want a page which shows all blog entries at url <code class="highlighter-rouge">/blog/entries/</code>.</p>

<p>We need following line in urls i.e <code class="highlighter-rouge">testcases/urls.py</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>url(r'^blog/', include('blog.urls')),
</code></pre></div></div>

<p><code class="highlighter-rouge">blog/urls.py</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>url(r'^entries/$', 'blog.views.entries', name='entries'),
</code></pre></div></div>

<p>Let’s add a test which satisfies our assumption.</p>

<p>Every app we create gets a <code class="highlighter-rouge">tests.py</code> where we can put our tests. You can remove the simple addition test generated by default by Django.</p>

<p><code class="highlighter-rouge">blog/tests.py</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from django.test import TestCase
from django.test.client import Client

class BlogEntriesTest(TestCase):

    def setUp(self):
        self.c = Client()

    def test_entries_access(self):
        response = self.c.get('/blog/entries/')
        self.assertEqual(response.status_code, 200)
</code></pre></div></div>

<p>###Explanation</p>

<ul>
  <li>We need a test class which is <code class="highlighter-rouge">BlogEntriesTest</code>. Any test class we write must subclass <strong>TestCase</strong> which is defined in <code class="highlighter-rouge">django.test</code>.</li>
  <li>Actual tests go in methods defined on the test class. So, our test goes in <code class="highlighter-rouge">test_entries_access</code>. Every test method name must start with <strong>test</strong> for it to be found by the django test runner.</li>
  <li>Before every test, <code class="highlighter-rouge">setUp</code> method is run. So anything which is common on all the test methods can go in <code class="highlighter-rouge">setUp</code>.</li>
  <li>We created a <code class="highlighter-rouge">Client</code> object in setUp. This object is needed to make <code class="highlighter-rouge">GET</code> or <code class="highlighter-rouge">POST</code> request. <code class="highlighter-rouge">Client</code> object simulates request to a url similar to a browser can. Since it is created in setUp, it will be available in all the test methods.</li>
  <li>From <code class="highlighter-rouge">test_entries_access</code>, we make a GET request to the url which we have defined. We capture the response in variable <strong>response</strong>.</li>
  <li>We are asserting that <code class="highlighter-rouge">status_code</code> of response must be 200 since we assumed this url to return a 200.</li>
</ul>

<p>###Running the test
Tests use a database. Since sqlite is faster than mysql or postgresql, we would use sqlite as the test database. You can continue using your any other database for development or production. We are only interested in running the tests using sqlite.</p>

<p><code class="highlighter-rouge">testcases/test_settings.py</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from settings import *
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'abc'
     }
}
</code></pre></div></div>

<p>Running the test.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python manage.py test blog --settings=testcases.test_settings
</code></pre></div></div>

<p><code class="highlighter-rouge">blog</code> says that only run the tests for app <code class="highlighter-rouge">blog</code>. Not providing this would run the tests for all the apps defined in INSTALLED_APPS which would take quite some time. Make sure that you have added <code class="highlighter-rouge">blog</code> to INSTALLED_APPS.</p>

<p><code class="highlighter-rouge">--settings</code> flag tells django test runner to use the specified settings file.</p>

<p><strong>And our test fails.</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERROR: test_entries_access (blog.tests.BlogEntriesTest)
----------------------------------------------------------------------
Traceback (most recent call last):
......
......
ViewDoesNotExist: Could not import blog.views.entries. View does not exist in module blog.views.

----------------------------------------------------------------------
Ran 1 test in 0.019s

FAILED (errors=1)
</code></pre></div></div>

<p>Because we have not written the view yet. We didn’t have to go to browser to check if this url works, our test does it for us.</p>

<p>We should test every url we want available in our project. So, that if some url breaks our test would tell that to us immediately.</p>

<p>###Adding the view</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from blog.models import BlogEntry
from django.shortcuts import render

def entries(request):
    entries = BlogEntry.objects.all()
    return render("blog/entries.html", {'entries': entries})
</code></pre></div></div>

<p>Make sure to add the template <code class="highlighter-rouge">blog/entries.html</code> in your template directory.</p>

<p>Run the test again.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python manage.py test blog --settings=testcases.test_settings

Ran 1 test in 0.019s

OK
Destroying test database for alias 'default'...
</code></pre></div></div>

<p>###Minor modification to test</p>

<p>Since we should not hardcode the urls, we will use <code class="highlighter-rouge">reverse</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_entries_access(self):
    response = self.c.get(reverse('entries'))
    self.assertEqual(response.status_code, 200)
</code></pre></div></div>

<p>Run the test again to make sure our change has not broken anything.</p>

<p>##Test that context is populated in template</p>

<p>We want to make sure that our expectation regarding number of visible blog entries on the page matches the result. Say we have two entries in the database then both of them should be shown on the page as per our view definition.</p>

<p>A blog must be associated with a user. So, we will create an instance of user in <code class="highlighter-rouge">setUp</code> because we would need this user in other tests as well.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def setUp(self):
    self.c = Client()
    self.user = User.objects.create_user(username="test", email="test@test.com", password="test")
</code></pre></div></div>

<p>###Testing the context</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_entries_template_context(self):
    #create few blog entries
    BlogEntry.objects.create(title='Test', text='Test', user=self.user)
    BlogEntry.objects.create(title='Test', text='Test', user=self.user)

    response = self.c.get(reverse('entries'))
    #assert that context contains as many entries as you expect
    self.assertEqual(len(response.context['entries']), 2)
</code></pre></div></div>

<p><code class="highlighter-rouge">response</code> contains an attribute <strong>context</strong> which is a dictionary containing the context sent to template.</p>

<p>###Assertion</p>
<ul>
  <li>We created two blogs and asserted that context contains both of them.</li>
</ul>

<p>This test is not much useful now. We will see how <code class="highlighter-rouge">response.context</code> becomes useful when we write a custom manager.</p>

<p>##Only logged in user must access create entry page.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_entry_create(self):
    response = self.c.get(reverse('entry_create'))
    self.assertEqual(response.status_code, 302)

    self.c.login(username='test', password='test')
    response = self.c.get(reverse('entry_create'))
    self.assertEqual(response.status_code, 200)
</code></pre></div></div>

<p>Run the test. We know it will fail because we have not written the view or the url yet.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python manage.py test blog --settings=testcases.test_settings

.....
ERROR: test_entry_create (blog.tests.BlogEntriesTest)
----------------------------------------------------------------------
Traceback (most recent call last):
....
NoReverseMatch: Reverse for 'entry_create' with arguments '()' and keyword arguments '{}' not found.
----------------------------------------------------------------------
Ran 3 tests in 0.051s

FAILED (errors=1)
</code></pre></div></div>

<p>###Explanation:</p>
<ul>
  <li>We expect a url with name <code class="highlighter-rouge">entry_create</code> to be available.</li>
  <li>A non-logged user should not be able to access this url and should be redirected to login urll. So, we assert that status code be 302.</li>
  <li>There is a <code class="highlighter-rouge">login</code> method defined on <code class="highlighter-rouge">Client</code>. So, we can call <code class="highlighter-rouge">self.c.login()</code>.</li>
  <li><code class="highlighter-rouge">login()</code> takes a username and password. You should provide credentials of some user already present in db. Remember we created an user in <code class="highlighter-rouge">setUp</code>. We pass the same credentials here.</li>
  <li>After this client i.e <code class="highlighter-rouge">self.c</code> starts behaving like a logged in user.</li>
  <li>Now client should be able to access create page and so we assert the status code as 200.</li>
</ul>

<p>Let’s start fixing this test.</p>

<p>Need to add following in <code class="highlighter-rouge">blog/urls.py</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>url(r'^entry/create/$', 'blog.views.entry_create', name='entry_create'),
</code></pre></div></div>

<p>Adding a modelform. This will be used in create view.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">class</span> <span class="n">BlogEntryForm</span><span class="p">(</span><span class="n">ModelForm</span><span class="p">):</span>                                                                          
    <span class="n">class</span> <span class="n">Meta</span><span class="p">:</span>
        <span class="k">model</span> <span class="p">=</span> <span class="n">BlogEntry</span>
</code></pre></div></div>

<p>Adding the view</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def entry_create(request):
    form = BlogEntryForm()
    if request.method == "POST":
        form = BlogEntryForm(request.POST)
        if form.is_valid():
            return HttpResponseRedirect(reverse('entries'))
            form.save()
    return render(request, "blog/entry_create.html", {'form': form})
</code></pre></div></div>

<p>Make sure to create the template. And then run the test.</p>

<p>You will still see an error.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>File "/home/akshar/play/dj/testcases/blog/tests.py", line 30, in test_entry_create
    self.assertEqual(response.status_code, 302)
AssertionError: 200 != 302
</code></pre></div></div>

<p>Because we missed adding <code class="highlighter-rouge">login_required</code> to the view and even anonymous users are able to access this url. And hence they are getting a 200 instead of 302.</p>

<p>Let’s fix it by adding <code class="highlighter-rouge">login_required</code> decorator to <code class="highlighter-rouge">entry_create</code> view.</p>

<p>Run the test again and it should pass now.</p>

<p>##Test invalid form</p>

<p>So, we wrote <code class="highlighter-rouge">entry_create</code> with assumption that it will handle POST requests.</p>

<p>We want to make sure that this view doesn’t allow invalid POST and raises an exception in that case.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_invalid_entry_create(self):
    self.c.login(username='test', password='test')
    data = {'text': 'Test text'}
    response = self.c.post(reverse('entry_create'), data)
    self.assertEqual(response.status_code, 200)
    self.assertFormError(response, "form", "title", "This field is required.")
</code></pre></div></div>

<p>###Assertions:</p>

<ul>
  <li>Since we posted an invalid form, we expect to remain on the same page. So asserted for status code of 200.</li>
  <li>We expect an error to be present on the <code class="highlighter-rouge">title</code> field.</li>
</ul>

<p>##Test valid form</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_valid_entry_create(self):
    self.c.login(username='test', password='test')
    data = {'text': 'Test text', 'title': 'Test title'}
    data['user'] = self.user.id
    self.assertEqual(BlogEntry.objects.count(), 0)
    response = self.c.post(reverse('entry_create'), data)
    self.assertEqual(response.status_code, 302)
    self.assertEqual(BlogEntry.objects.count(), 1)
</code></pre></div></div>

<p>###Assertions:</p>

<ul>
  <li>Before posting we assert that there is no <code class="highlighter-rouge">BlogEntry</code> in the db.</li>
  <li>After posting we check that the user is redirected and so asserted for status code of 302</li>
  <li>We make sure that a <code class="highlighter-rouge">BlogEntry</code> is created in the database on post by checking that count of <code class="highlighter-rouge">BlogEntry</code> has been increased to 1.</li>
</ul>

<p>##Test custom manager methods</p>

<p>Suppose you find yourself writing the same filter multiple times for getting the blog entries which have is_published as True. In that case you would write a custom manager.</p>

<p>We will add the custom manager in models.py</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class PublishedBlogManager(models.Manager):
    def get_query_set(self, *args, **kwargs):
        return super(PublishedBlogManager, self).get_query_set(*args, **kwargs).filter(is_published=True)
</code></pre></div></div>

<p>Also we need to add this manager on <code class="highlighter-rouge">BlogEntry</code>. So, don’t forget to add next two lines to <code class="highlighter-rouge">BlogEntry</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>objects = models.Manager()
published = PublishedBlogManager()
</code></pre></div></div>

<p>Let’s write a test now:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_entry_custom_managers(self):
    BlogEntry.objects.create(title='Test', text='Test', user=self.user, is_published=False)
    BlogEntry.objects.create(title='Test', text='Test', user=self.user)
    self.assertEqual(BlogEntry.objects.count(), 2)
    self.assertEqual(BlogEntry.published.count(), 1)
</code></pre></div></div>

<p>###Assertions:</p>

<ul>
  <li>We created two entries. One with is_published as False, and another with True.</li>
  <li><code class="highlighter-rouge">objects</code> i.e default manager returns all the entries.</li>
  <li><code class="highlighter-rouge">published</code> i.e custom manager returns only entries which have <code class="highlighter-rouge">is_published=True</code>.</li>
</ul>

<p>###Using custom manager in <strong>test_entries_template_context</strong>:</p>

<p>Say now we decide that all entries should not be shown on list entries page. Only published entries should be shown.</p>

<p>Remember <code class="highlighter-rouge">test_entries_template_context</code>. We only created two blog entries in that test. Edit that test and create one more entry with <code class="highlighter-rouge">is_published=False</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_entries_template_context(self):
    #create few blog entries
    BlogEntry.objects.create(title='Test', text='Test', user=self.user)
    BlogEntry.objects.create(title='Test', text='Test', user=self.user)
    BlogEntry.objects.create(title='Test', text='Test', user=self.user, is_published=False)

    response = self.c.get(reverse('entries'))
    #assert that context contains only published entries
    self.assertEqual(len(response.context['entries']), 2)
</code></pre></div></div>

<p>We created three entries. Only two of them are published.</p>

<p>###Assertion:</p>
<ul>
  <li>Entries page should only show 2 entries.</li>
</ul>

<p>Run the test and it will fail.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>======================================================================
FAIL: test_entries_template_context (blog.tests.BlogEntriesTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/akshar/play/dj/testcases/blog/tests.py", line 29, in test_entries_template_context
    self.assertEqual(len(response.context['entries']), 2)
AssertionError: 3 != 2

----------------------------------------------------------------------
</code></pre></div></div>

<p>Happened because we forgot to change our view. Our view still says <code class="highlighter-rouge">BlogEntry.objects.all()</code>. We should change it to <code class="highlighter-rouge">BlogEntry.published.all()</code>. Make this change and the test will pass.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def entries(request):
    entries = BlogEntry.published.all()
    return render_to_response("blog/entries.html", {'entries': entries})
</code></pre></div></div>

<p>So, <strong>response.context</strong> helped us find that we do not show more entries than we should.</p>

<p>##Test for pagination</p>

<p>Suppose we expect maximum ten entries to be available on each page. There are 15 entries in the db, so first page should show 10 entries and the second page should show 5. If user tries to access the third page a 404 page should be shown.</p>

<p>Our decided url pattern for getting entries on a particular page:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>url(r'^entries/(?P&lt;page&gt;\d+)/$', 'blog.views.entries_page', name='entries_page')
</code></pre></div></div>

<p>Writing the test:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_entries_page(self):
    for i in range(15):
        BlogEntry.objects.create(title="title", text="text", user=self.user, is_published=True)

    #access first page
    response = self.c.get(reverse("entries_page", args=[1,]))
    self.assertEqual(response.status_code, 200)
    self.assertEqual(len(response.context['entries']), 10)
    
    #access second page
    response = self.c.get(reverse("entries_page", args=[2,]))
    self.assertEqual(response.status_code, 200)
    self.assertEqual(len(response.context['entries']), 5)
</code></pre></div></div>

<p>Run the test and it will fail. Let’s add view to make it pass.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def entries_page(request, page):
    page = int(page)
    entries = BlogEntry.published.all()
    paginator = Paginator(entries, 10) #10 entries per page
    page_ = paginator.page(page)
    object_list = page_.object_list
    return render(request, "blog/entries_page.html", {"entries": object_list})
</code></pre></div></div>

<p>Test should pass now provided you have added the template.</p>

<p>Let’s try to access third page in the test. We need to add following in <code class="highlighter-rouge">test_entries_page</code> for that.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #access third page
    response = self.c.get(reverse("entries_page", args=[3,]))
    self.assertEqual(response.status_code, 404)
</code></pre></div></div>

<p>Running the test raises an error.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>....
raise EmptyPage('That page contains no results')
EmptyPage: That page contains no results
</code></pre></div></div>

<p>We find that there is a bug in our view and any page which doesn’t contain entries is not being handled as we want. Let’s change our view:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def entries_page(request, page):
    page = int(page)
    entries = BlogEntry.published.all()
    paginator = Paginator(entries, 10) #10 entries per page
    if page &gt; paginator.num_pages:
        raise Http404()
    page_ = paginator.page(page)
    object_list = page_.object_list
    return render(request, "blog/entries_page.html", {"entries": object_list})
</code></pre></div></div>

<p>Run the test again.</p>

<p>If you have a 404 template defined then your test will pass. In this project we do not have a 404 template and so we get another exception</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERROR: test_entries_page (blog.tests.BlogEntriesTest)
----------------------------------------------------------------------
Traceback (most recent call last):
....
    raise TemplateDoesNotExist(name)
TemplateDoesNotExist: 404.html
</code></pre></div></div>

<p>So, let’s add a 404 template. Test passes once we do it.</p>

<p>So, this test also helped us find a missing 404 template.</p>

<p>##Test for static files</p>

<p>You can look at <a href="http://agiliq.com/blog/2013/03/serving-static-files-in-django/">our blog on static file</a> if you have some confusion regarding how static files are served in Django.</p>

<p>We will create a <code class="highlighter-rouge">static</code> directory in our app <code class="highlighter-rouge">blog</code> and will put an image in this directory. Let’s say this image is <code class="highlighter-rouge">default.jpg</code></p>

<p>Let’s add a test to make sure this image is found by django static file handlers. This test makes us confident that we can expect this image to be served at <code class="highlighter-rouge">default.jpg</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from django.contrib.staticfiles import finders
from django.contrib.staticfiles.storage import staticfiles_storage

def test_images(self):
    abs_path = finders.find('default.jpg')
    self.assertTrue(staticfiles_storage.exists(abs_path))
</code></pre></div></div>

<p>Run the test and it should pass.</p>

<p>You can view the complete project <a href="https://github.com/akshar-raaj/Testing-in-Django">here</a>.</p>


  </div><a class="u-url" href="/testing/2013/04/28/common-testing-scenarios-for-django-app.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Agiliq Blogs</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Agiliq Blogs</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
