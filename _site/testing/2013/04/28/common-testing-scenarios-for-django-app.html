<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Common testing scenarios for Django app. | Agiliq Blogs</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Common testing scenarios for Django app." />
<meta name="author" content="akshar" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="People are often confused regarding what tests to write. Let’s look into some scenarios for which tests can be written. ##Setting up the project We start a Django project inside a virtual environment. In this post we would be using django 1.4. (dj)~/play/dj$ django-admin.py startproject testcases Let’s start an app named blog. (dj)~/play/dj/testcases$ python manage.py startapp blog We will have the following model in blog/models.py: class BlogEntry(models.Model): title = models.CharField(max_length=100) text = models.TextField() is_published = models.BooleanField(default=True) user = models.ForeignKey(User) We will do test driven development which requires: Thinking about our assumption. Writing the test to satisfy that assumption. Run the test and it will fail since we won’t have view written till this point. Adding the view. Run the test and fixing the view or anything else till our test passes. If I could not explain the project structure properly, you can find the complete project here. ##First test We want a page which shows all blog entries at url /blog/entries/. We need following line in urls i.e testcases/urls.py url(r&#39;^blog/&#39;, include(&#39;blog.urls&#39;)), blog/urls.py url(r&#39;^entries/$&#39;, &#39;blog.views.entries&#39;, name=&#39;entries&#39;), Let’s add a test which satisfies our assumption. Every app we create gets a tests.py where we can put our tests. You can remove the simple addition test generated by default by Django. blog/tests.py from django.test import TestCase from django.test.client import Client class BlogEntriesTest(TestCase): def setUp(self): self.c = Client() def test_entries_access(self): response = self.c.get(&#39;/blog/entries/&#39;) self.assertEqual(response.status_code, 200) ###Explanation We need a test class which is BlogEntriesTest. Any test class we write must subclass TestCase which is defined in django.test. Actual tests go in methods defined on the test class. So, our test goes in test_entries_access. Every test method name must start with test for it to be found by the django test runner. Before every test, setUp method is run. So anything which is common on all the test methods can go in setUp. We created a Client object in setUp. This object is needed to make GET or POST request. Client object simulates request to a url similar to a browser can. Since it is created in setUp, it will be available in all the test methods. From test_entries_access, we make a GET request to the url which we have defined. We capture the response in variable response. We are asserting that status_code of response must be 200 since we assumed this url to return a 200. ###Running the test Tests use a database. Since sqlite is faster than mysql or postgresql, we would use sqlite as the test database. You can continue using your any other database for development or production. We are only interested in running the tests using sqlite. testcases/test_settings.py from settings import * DATABASES = { &#39;default&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;, &#39;NAME&#39;: &#39;abc&#39; } } Running the test. python manage.py test blog --settings=testcases.test_settings blog says that only run the tests for app blog. Not providing this would run the tests for all the apps defined in INSTALLED_APPS which would take quite some time. Make sure that you have added blog to INSTALLED_APPS. --settings flag tells django test runner to use the specified settings file. And our test fails. ERROR: test_entries_access (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): ...... ...... ViewDoesNotExist: Could not import blog.views.entries. View does not exist in module blog.views. ---------------------------------------------------------------------- Ran 1 test in 0.019s FAILED (errors=1) Because we have not written the view yet. We didn’t have to go to browser to check if this url works, our test does it for us. We should test every url we want available in our project. So, that if some url breaks our test would tell that to us immediately. ###Adding the view from blog.models import BlogEntry from django.shortcuts import render def entries(request): entries = BlogEntry.objects.all() return render(&quot;blog/entries.html&quot;, {&#39;entries&#39;: entries}) Make sure to add the template blog/entries.html in your template directory. Run the test again. python manage.py test blog --settings=testcases.test_settings Ran 1 test in 0.019s OK Destroying test database for alias &#39;default&#39;... ###Minor modification to test Since we should not hardcode the urls, we will use reverse. def test_entries_access(self): response = self.c.get(reverse(&#39;entries&#39;)) self.assertEqual(response.status_code, 200) Run the test again to make sure our change has not broken anything. ##Test that context is populated in template We want to make sure that our expectation regarding number of visible blog entries on the page matches the result. Say we have two entries in the database then both of them should be shown on the page as per our view definition. A blog must be associated with a user. So, we will create an instance of user in setUp because we would need this user in other tests as well. def setUp(self): self.c = Client() self.user = User.objects.create_user(username=&quot;test&quot;, email=&quot;test@test.com&quot;, password=&quot;test&quot;) ###Testing the context def test_entries_template_context(self): #create few blog entries BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) response = self.c.get(reverse(&#39;entries&#39;)) #assert that context contains as many entries as you expect self.assertEqual(len(response.context[&#39;entries&#39;]), 2) response contains an attribute context which is a dictionary containing the context sent to template. ###Assertion We created two blogs and asserted that context contains both of them. This test is not much useful now. We will see how response.context becomes useful when we write a custom manager. ##Only logged in user must access create entry page. def test_entry_create(self): response = self.c.get(reverse(&#39;entry_create&#39;)) self.assertEqual(response.status_code, 302) self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) response = self.c.get(reverse(&#39;entry_create&#39;)) self.assertEqual(response.status_code, 200) Run the test. We know it will fail because we have not written the view or the url yet. python manage.py test blog --settings=testcases.test_settings ..... ERROR: test_entry_create (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): .... NoReverseMatch: Reverse for &#39;entry_create&#39; with arguments &#39;()&#39; and keyword arguments &#39;{}&#39; not found. ---------------------------------------------------------------------- Ran 3 tests in 0.051s FAILED (errors=1) ###Explanation: We expect a url with name entry_create to be available. A non-logged user should not be able to access this url and should be redirected to login urll. So, we assert that status code be 302. There is a login method defined on Client. So, we can call self.c.login(). login() takes a username and password. You should provide credentials of some user already present in db. Remember we created an user in setUp. We pass the same credentials here. After this client i.e self.c starts behaving like a logged in user. Now client should be able to access create page and so we assert the status code as 200. Let’s start fixing this test. Need to add following in blog/urls.py url(r&#39;^entry/create/$&#39;, &#39;blog.views.entry_create&#39;, name=&#39;entry_create&#39;), Adding a modelform. This will be used in create view. class BlogEntryForm(ModelForm): class Meta: model = BlogEntry Adding the view def entry_create(request): form = BlogEntryForm() if request.method == &quot;POST&quot;: form = BlogEntryForm(request.POST) if form.is_valid(): return HttpResponseRedirect(reverse(&#39;entries&#39;)) form.save() return render(request, &quot;blog/entry_create.html&quot;, {&#39;form&#39;: form}) Make sure to create the template. And then run the test. You will still see an error. File &quot;/home/akshar/play/dj/testcases/blog/tests.py&quot;, line 30, in test_entry_create self.assertEqual(response.status_code, 302) AssertionError: 200 != 302 Because we missed adding login_required to the view and even anonymous users are able to access this url. And hence they are getting a 200 instead of 302. Let’s fix it by adding login_required decorator to entry_create view. Run the test again and it should pass now. ##Test invalid form So, we wrote entry_create with assumption that it will handle POST requests. We want to make sure that this view doesn’t allow invalid POST and raises an exception in that case. def test_invalid_entry_create(self): self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) data = {&#39;text&#39;: &#39;Test text&#39;} response = self.c.post(reverse(&#39;entry_create&#39;), data) self.assertEqual(response.status_code, 200) self.assertFormError(response, &quot;form&quot;, &quot;title&quot;, &quot;This field is required.&quot;) ###Assertions: Since we posted an invalid form, we expect to remain on the same page. So asserted for status code of 200. We expect an error to be present on the title field. ##Test valid form def test_valid_entry_create(self): self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) data = {&#39;text&#39;: &#39;Test text&#39;, &#39;title&#39;: &#39;Test title&#39;} data[&#39;user&#39;] = self.user.id self.assertEqual(BlogEntry.objects.count(), 0) response = self.c.post(reverse(&#39;entry_create&#39;), data) self.assertEqual(response.status_code, 302) self.assertEqual(BlogEntry.objects.count(), 1) ###Assertions: Before posting we assert that there is no BlogEntry in the db. After posting we check that the user is redirected and so asserted for status code of 302 We make sure that a BlogEntry is created in the database on post by checking that count of BlogEntry has been increased to 1. ##Test custom manager methods Suppose you find yourself writing the same filter multiple times for getting the blog entries which have is_published as True. In that case you would write a custom manager. We will add the custom manager in models.py class PublishedBlogManager(models.Manager): def get_query_set(self, *args, **kwargs): return super(PublishedBlogManager, self).get_query_set(*args, **kwargs).filter(is_published=True) Also we need to add this manager on BlogEntry. So, don’t forget to add next two lines to BlogEntry objects = models.Manager() published = PublishedBlogManager() Let’s write a test now: def test_entry_custom_managers(self): BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user, is_published=False) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) self.assertEqual(BlogEntry.objects.count(), 2) self.assertEqual(BlogEntry.published.count(), 1) ###Assertions: We created two entries. One with is_published as False, and another with True. objects i.e default manager returns all the entries. published i.e custom manager returns only entries which have is_published=True. ###Using custom manager in test_entries_template_context: Say now we decide that all entries should not be shown on list entries page. Only published entries should be shown. Remember test_entries_template_context. We only created two blog entries in that test. Edit that test and create one more entry with is_published=False def test_entries_template_context(self): #create few blog entries BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user, is_published=False) response = self.c.get(reverse(&#39;entries&#39;)) #assert that context contains only published entries self.assertEqual(len(response.context[&#39;entries&#39;]), 2) We created three entries. Only two of them are published. ###Assertion: Entries page should only show 2 entries. Run the test and it will fail. ====================================================================== FAIL: test_entries_template_context (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;/home/akshar/play/dj/testcases/blog/tests.py&quot;, line 29, in test_entries_template_context self.assertEqual(len(response.context[&#39;entries&#39;]), 2) AssertionError: 3 != 2 ---------------------------------------------------------------------- Happened because we forgot to change our view. Our view still says BlogEntry.objects.all(). We should change it to BlogEntry.published.all(). Make this change and the test will pass. def entries(request): entries = BlogEntry.published.all() return render_to_response(&quot;blog/entries.html&quot;, {&#39;entries&#39;: entries}) So, response.context helped us find that we do not show more entries than we should. ##Test for pagination Suppose we expect maximum ten entries to be available on each page. There are 15 entries in the db, so first page should show 10 entries and the second page should show 5. If user tries to access the third page a 404 page should be shown. Our decided url pattern for getting entries on a particular page: url(r&#39;^entries/(?P&lt;page&gt;\d+)/$&#39;, &#39;blog.views.entries_page&#39;, name=&#39;entries_page&#39;) Writing the test: def test_entries_page(self): for i in range(15): BlogEntry.objects.create(title=&quot;title&quot;, text=&quot;text&quot;, user=self.user, is_published=True) #access first page response = self.c.get(reverse(&quot;entries_page&quot;, args=[1,])) self.assertEqual(response.status_code, 200) self.assertEqual(len(response.context[&#39;entries&#39;]), 10) #access second page response = self.c.get(reverse(&quot;entries_page&quot;, args=[2,])) self.assertEqual(response.status_code, 200) self.assertEqual(len(response.context[&#39;entries&#39;]), 5) Run the test and it will fail. Let’s add view to make it pass. def entries_page(request, page): page = int(page) entries = BlogEntry.published.all() paginator = Paginator(entries, 10) #10 entries per page page_ = paginator.page(page) object_list = page_.object_list return render(request, &quot;blog/entries_page.html&quot;, {&quot;entries&quot;: object_list}) Test should pass now provided you have added the template. Let’s try to access third page in the test. We need to add following in test_entries_page for that. #access third page response = self.c.get(reverse(&quot;entries_page&quot;, args=[3,])) self.assertEqual(response.status_code, 404) Running the test raises an error. .... raise EmptyPage(&#39;That page contains no results&#39;) EmptyPage: That page contains no results We find that there is a bug in our view and any page which doesn’t contain entries is not being handled as we want. Let’s change our view: def entries_page(request, page): page = int(page) entries = BlogEntry.published.all() paginator = Paginator(entries, 10) #10 entries per page if page &gt; paginator.num_pages: raise Http404() page_ = paginator.page(page) object_list = page_.object_list return render(request, &quot;blog/entries_page.html&quot;, {&quot;entries&quot;: object_list}) Run the test again. If you have a 404 template defined then your test will pass. In this project we do not have a 404 template and so we get another exception ERROR: test_entries_page (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): .... raise TemplateDoesNotExist(name) TemplateDoesNotExist: 404.html So, let’s add a 404 template. Test passes once we do it. So, this test also helped us find a missing 404 template. ##Test for static files You can look at our blog on static file if you have some confusion regarding how static files are served in Django. We will create a static directory in our app blog and will put an image in this directory. Let’s say this image is default.jpg Let’s add a test to make sure this image is found by django static file handlers. This test makes us confident that we can expect this image to be served at default.jpg from django.contrib.staticfiles import finders from django.contrib.staticfiles.storage import staticfiles_storage def test_images(self): abs_path = finders.find(&#39;default.jpg&#39;) self.assertTrue(staticfiles_storage.exists(abs_path)) Run the test and it should pass. You can view the complete project here." />
<meta property="og:description" content="People are often confused regarding what tests to write. Let’s look into some scenarios for which tests can be written. ##Setting up the project We start a Django project inside a virtual environment. In this post we would be using django 1.4. (dj)~/play/dj$ django-admin.py startproject testcases Let’s start an app named blog. (dj)~/play/dj/testcases$ python manage.py startapp blog We will have the following model in blog/models.py: class BlogEntry(models.Model): title = models.CharField(max_length=100) text = models.TextField() is_published = models.BooleanField(default=True) user = models.ForeignKey(User) We will do test driven development which requires: Thinking about our assumption. Writing the test to satisfy that assumption. Run the test and it will fail since we won’t have view written till this point. Adding the view. Run the test and fixing the view or anything else till our test passes. If I could not explain the project structure properly, you can find the complete project here. ##First test We want a page which shows all blog entries at url /blog/entries/. We need following line in urls i.e testcases/urls.py url(r&#39;^blog/&#39;, include(&#39;blog.urls&#39;)), blog/urls.py url(r&#39;^entries/$&#39;, &#39;blog.views.entries&#39;, name=&#39;entries&#39;), Let’s add a test which satisfies our assumption. Every app we create gets a tests.py where we can put our tests. You can remove the simple addition test generated by default by Django. blog/tests.py from django.test import TestCase from django.test.client import Client class BlogEntriesTest(TestCase): def setUp(self): self.c = Client() def test_entries_access(self): response = self.c.get(&#39;/blog/entries/&#39;) self.assertEqual(response.status_code, 200) ###Explanation We need a test class which is BlogEntriesTest. Any test class we write must subclass TestCase which is defined in django.test. Actual tests go in methods defined on the test class. So, our test goes in test_entries_access. Every test method name must start with test for it to be found by the django test runner. Before every test, setUp method is run. So anything which is common on all the test methods can go in setUp. We created a Client object in setUp. This object is needed to make GET or POST request. Client object simulates request to a url similar to a browser can. Since it is created in setUp, it will be available in all the test methods. From test_entries_access, we make a GET request to the url which we have defined. We capture the response in variable response. We are asserting that status_code of response must be 200 since we assumed this url to return a 200. ###Running the test Tests use a database. Since sqlite is faster than mysql or postgresql, we would use sqlite as the test database. You can continue using your any other database for development or production. We are only interested in running the tests using sqlite. testcases/test_settings.py from settings import * DATABASES = { &#39;default&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;, &#39;NAME&#39;: &#39;abc&#39; } } Running the test. python manage.py test blog --settings=testcases.test_settings blog says that only run the tests for app blog. Not providing this would run the tests for all the apps defined in INSTALLED_APPS which would take quite some time. Make sure that you have added blog to INSTALLED_APPS. --settings flag tells django test runner to use the specified settings file. And our test fails. ERROR: test_entries_access (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): ...... ...... ViewDoesNotExist: Could not import blog.views.entries. View does not exist in module blog.views. ---------------------------------------------------------------------- Ran 1 test in 0.019s FAILED (errors=1) Because we have not written the view yet. We didn’t have to go to browser to check if this url works, our test does it for us. We should test every url we want available in our project. So, that if some url breaks our test would tell that to us immediately. ###Adding the view from blog.models import BlogEntry from django.shortcuts import render def entries(request): entries = BlogEntry.objects.all() return render(&quot;blog/entries.html&quot;, {&#39;entries&#39;: entries}) Make sure to add the template blog/entries.html in your template directory. Run the test again. python manage.py test blog --settings=testcases.test_settings Ran 1 test in 0.019s OK Destroying test database for alias &#39;default&#39;... ###Minor modification to test Since we should not hardcode the urls, we will use reverse. def test_entries_access(self): response = self.c.get(reverse(&#39;entries&#39;)) self.assertEqual(response.status_code, 200) Run the test again to make sure our change has not broken anything. ##Test that context is populated in template We want to make sure that our expectation regarding number of visible blog entries on the page matches the result. Say we have two entries in the database then both of them should be shown on the page as per our view definition. A blog must be associated with a user. So, we will create an instance of user in setUp because we would need this user in other tests as well. def setUp(self): self.c = Client() self.user = User.objects.create_user(username=&quot;test&quot;, email=&quot;test@test.com&quot;, password=&quot;test&quot;) ###Testing the context def test_entries_template_context(self): #create few blog entries BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) response = self.c.get(reverse(&#39;entries&#39;)) #assert that context contains as many entries as you expect self.assertEqual(len(response.context[&#39;entries&#39;]), 2) response contains an attribute context which is a dictionary containing the context sent to template. ###Assertion We created two blogs and asserted that context contains both of them. This test is not much useful now. We will see how response.context becomes useful when we write a custom manager. ##Only logged in user must access create entry page. def test_entry_create(self): response = self.c.get(reverse(&#39;entry_create&#39;)) self.assertEqual(response.status_code, 302) self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) response = self.c.get(reverse(&#39;entry_create&#39;)) self.assertEqual(response.status_code, 200) Run the test. We know it will fail because we have not written the view or the url yet. python manage.py test blog --settings=testcases.test_settings ..... ERROR: test_entry_create (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): .... NoReverseMatch: Reverse for &#39;entry_create&#39; with arguments &#39;()&#39; and keyword arguments &#39;{}&#39; not found. ---------------------------------------------------------------------- Ran 3 tests in 0.051s FAILED (errors=1) ###Explanation: We expect a url with name entry_create to be available. A non-logged user should not be able to access this url and should be redirected to login urll. So, we assert that status code be 302. There is a login method defined on Client. So, we can call self.c.login(). login() takes a username and password. You should provide credentials of some user already present in db. Remember we created an user in setUp. We pass the same credentials here. After this client i.e self.c starts behaving like a logged in user. Now client should be able to access create page and so we assert the status code as 200. Let’s start fixing this test. Need to add following in blog/urls.py url(r&#39;^entry/create/$&#39;, &#39;blog.views.entry_create&#39;, name=&#39;entry_create&#39;), Adding a modelform. This will be used in create view. class BlogEntryForm(ModelForm): class Meta: model = BlogEntry Adding the view def entry_create(request): form = BlogEntryForm() if request.method == &quot;POST&quot;: form = BlogEntryForm(request.POST) if form.is_valid(): return HttpResponseRedirect(reverse(&#39;entries&#39;)) form.save() return render(request, &quot;blog/entry_create.html&quot;, {&#39;form&#39;: form}) Make sure to create the template. And then run the test. You will still see an error. File &quot;/home/akshar/play/dj/testcases/blog/tests.py&quot;, line 30, in test_entry_create self.assertEqual(response.status_code, 302) AssertionError: 200 != 302 Because we missed adding login_required to the view and even anonymous users are able to access this url. And hence they are getting a 200 instead of 302. Let’s fix it by adding login_required decorator to entry_create view. Run the test again and it should pass now. ##Test invalid form So, we wrote entry_create with assumption that it will handle POST requests. We want to make sure that this view doesn’t allow invalid POST and raises an exception in that case. def test_invalid_entry_create(self): self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) data = {&#39;text&#39;: &#39;Test text&#39;} response = self.c.post(reverse(&#39;entry_create&#39;), data) self.assertEqual(response.status_code, 200) self.assertFormError(response, &quot;form&quot;, &quot;title&quot;, &quot;This field is required.&quot;) ###Assertions: Since we posted an invalid form, we expect to remain on the same page. So asserted for status code of 200. We expect an error to be present on the title field. ##Test valid form def test_valid_entry_create(self): self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) data = {&#39;text&#39;: &#39;Test text&#39;, &#39;title&#39;: &#39;Test title&#39;} data[&#39;user&#39;] = self.user.id self.assertEqual(BlogEntry.objects.count(), 0) response = self.c.post(reverse(&#39;entry_create&#39;), data) self.assertEqual(response.status_code, 302) self.assertEqual(BlogEntry.objects.count(), 1) ###Assertions: Before posting we assert that there is no BlogEntry in the db. After posting we check that the user is redirected and so asserted for status code of 302 We make sure that a BlogEntry is created in the database on post by checking that count of BlogEntry has been increased to 1. ##Test custom manager methods Suppose you find yourself writing the same filter multiple times for getting the blog entries which have is_published as True. In that case you would write a custom manager. We will add the custom manager in models.py class PublishedBlogManager(models.Manager): def get_query_set(self, *args, **kwargs): return super(PublishedBlogManager, self).get_query_set(*args, **kwargs).filter(is_published=True) Also we need to add this manager on BlogEntry. So, don’t forget to add next two lines to BlogEntry objects = models.Manager() published = PublishedBlogManager() Let’s write a test now: def test_entry_custom_managers(self): BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user, is_published=False) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) self.assertEqual(BlogEntry.objects.count(), 2) self.assertEqual(BlogEntry.published.count(), 1) ###Assertions: We created two entries. One with is_published as False, and another with True. objects i.e default manager returns all the entries. published i.e custom manager returns only entries which have is_published=True. ###Using custom manager in test_entries_template_context: Say now we decide that all entries should not be shown on list entries page. Only published entries should be shown. Remember test_entries_template_context. We only created two blog entries in that test. Edit that test and create one more entry with is_published=False def test_entries_template_context(self): #create few blog entries BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user, is_published=False) response = self.c.get(reverse(&#39;entries&#39;)) #assert that context contains only published entries self.assertEqual(len(response.context[&#39;entries&#39;]), 2) We created three entries. Only two of them are published. ###Assertion: Entries page should only show 2 entries. Run the test and it will fail. ====================================================================== FAIL: test_entries_template_context (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;/home/akshar/play/dj/testcases/blog/tests.py&quot;, line 29, in test_entries_template_context self.assertEqual(len(response.context[&#39;entries&#39;]), 2) AssertionError: 3 != 2 ---------------------------------------------------------------------- Happened because we forgot to change our view. Our view still says BlogEntry.objects.all(). We should change it to BlogEntry.published.all(). Make this change and the test will pass. def entries(request): entries = BlogEntry.published.all() return render_to_response(&quot;blog/entries.html&quot;, {&#39;entries&#39;: entries}) So, response.context helped us find that we do not show more entries than we should. ##Test for pagination Suppose we expect maximum ten entries to be available on each page. There are 15 entries in the db, so first page should show 10 entries and the second page should show 5. If user tries to access the third page a 404 page should be shown. Our decided url pattern for getting entries on a particular page: url(r&#39;^entries/(?P&lt;page&gt;\d+)/$&#39;, &#39;blog.views.entries_page&#39;, name=&#39;entries_page&#39;) Writing the test: def test_entries_page(self): for i in range(15): BlogEntry.objects.create(title=&quot;title&quot;, text=&quot;text&quot;, user=self.user, is_published=True) #access first page response = self.c.get(reverse(&quot;entries_page&quot;, args=[1,])) self.assertEqual(response.status_code, 200) self.assertEqual(len(response.context[&#39;entries&#39;]), 10) #access second page response = self.c.get(reverse(&quot;entries_page&quot;, args=[2,])) self.assertEqual(response.status_code, 200) self.assertEqual(len(response.context[&#39;entries&#39;]), 5) Run the test and it will fail. Let’s add view to make it pass. def entries_page(request, page): page = int(page) entries = BlogEntry.published.all() paginator = Paginator(entries, 10) #10 entries per page page_ = paginator.page(page) object_list = page_.object_list return render(request, &quot;blog/entries_page.html&quot;, {&quot;entries&quot;: object_list}) Test should pass now provided you have added the template. Let’s try to access third page in the test. We need to add following in test_entries_page for that. #access third page response = self.c.get(reverse(&quot;entries_page&quot;, args=[3,])) self.assertEqual(response.status_code, 404) Running the test raises an error. .... raise EmptyPage(&#39;That page contains no results&#39;) EmptyPage: That page contains no results We find that there is a bug in our view and any page which doesn’t contain entries is not being handled as we want. Let’s change our view: def entries_page(request, page): page = int(page) entries = BlogEntry.published.all() paginator = Paginator(entries, 10) #10 entries per page if page &gt; paginator.num_pages: raise Http404() page_ = paginator.page(page) object_list = page_.object_list return render(request, &quot;blog/entries_page.html&quot;, {&quot;entries&quot;: object_list}) Run the test again. If you have a 404 template defined then your test will pass. In this project we do not have a 404 template and so we get another exception ERROR: test_entries_page (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): .... raise TemplateDoesNotExist(name) TemplateDoesNotExist: 404.html So, let’s add a 404 template. Test passes once we do it. So, this test also helped us find a missing 404 template. ##Test for static files You can look at our blog on static file if you have some confusion regarding how static files are served in Django. We will create a static directory in our app blog and will put an image in this directory. Let’s say this image is default.jpg Let’s add a test to make sure this image is found by django static file handlers. This test makes us confident that we can expect this image to be served at default.jpg from django.contrib.staticfiles import finders from django.contrib.staticfiles.storage import staticfiles_storage def test_images(self): abs_path = finders.find(&#39;default.jpg&#39;) self.assertTrue(staticfiles_storage.exists(abs_path)) Run the test and it should pass. You can view the complete project here." />
<link rel="canonical" href="http://localhost:4000/testing/2013/04/28/common-testing-scenarios-for-django-app.html" />
<meta property="og:url" content="http://localhost:4000/testing/2013/04/28/common-testing-scenarios-for-django-app.html" />
<meta property="og:site_name" content="Agiliq Blogs" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-04-28T20:33:38+05:30" />
<script type="application/ld+json">
{"description":"People are often confused regarding what tests to write. Let’s look into some scenarios for which tests can be written. ##Setting up the project We start a Django project inside a virtual environment. In this post we would be using django 1.4. (dj)~/play/dj$ django-admin.py startproject testcases Let’s start an app named blog. (dj)~/play/dj/testcases$ python manage.py startapp blog We will have the following model in blog/models.py: class BlogEntry(models.Model): title = models.CharField(max_length=100) text = models.TextField() is_published = models.BooleanField(default=True) user = models.ForeignKey(User) We will do test driven development which requires: Thinking about our assumption. Writing the test to satisfy that assumption. Run the test and it will fail since we won’t have view written till this point. Adding the view. Run the test and fixing the view or anything else till our test passes. If I could not explain the project structure properly, you can find the complete project here. ##First test We want a page which shows all blog entries at url /blog/entries/. We need following line in urls i.e testcases/urls.py url(r&#39;^blog/&#39;, include(&#39;blog.urls&#39;)), blog/urls.py url(r&#39;^entries/$&#39;, &#39;blog.views.entries&#39;, name=&#39;entries&#39;), Let’s add a test which satisfies our assumption. Every app we create gets a tests.py where we can put our tests. You can remove the simple addition test generated by default by Django. blog/tests.py from django.test import TestCase from django.test.client import Client class BlogEntriesTest(TestCase): def setUp(self): self.c = Client() def test_entries_access(self): response = self.c.get(&#39;/blog/entries/&#39;) self.assertEqual(response.status_code, 200) ###Explanation We need a test class which is BlogEntriesTest. Any test class we write must subclass TestCase which is defined in django.test. Actual tests go in methods defined on the test class. So, our test goes in test_entries_access. Every test method name must start with test for it to be found by the django test runner. Before every test, setUp method is run. So anything which is common on all the test methods can go in setUp. We created a Client object in setUp. This object is needed to make GET or POST request. Client object simulates request to a url similar to a browser can. Since it is created in setUp, it will be available in all the test methods. From test_entries_access, we make a GET request to the url which we have defined. We capture the response in variable response. We are asserting that status_code of response must be 200 since we assumed this url to return a 200. ###Running the test Tests use a database. Since sqlite is faster than mysql or postgresql, we would use sqlite as the test database. You can continue using your any other database for development or production. We are only interested in running the tests using sqlite. testcases/test_settings.py from settings import * DATABASES = { &#39;default&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;, &#39;NAME&#39;: &#39;abc&#39; } } Running the test. python manage.py test blog --settings=testcases.test_settings blog says that only run the tests for app blog. Not providing this would run the tests for all the apps defined in INSTALLED_APPS which would take quite some time. Make sure that you have added blog to INSTALLED_APPS. --settings flag tells django test runner to use the specified settings file. And our test fails. ERROR: test_entries_access (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): ...... ...... ViewDoesNotExist: Could not import blog.views.entries. View does not exist in module blog.views. ---------------------------------------------------------------------- Ran 1 test in 0.019s FAILED (errors=1) Because we have not written the view yet. We didn’t have to go to browser to check if this url works, our test does it for us. We should test every url we want available in our project. So, that if some url breaks our test would tell that to us immediately. ###Adding the view from blog.models import BlogEntry from django.shortcuts import render def entries(request): entries = BlogEntry.objects.all() return render(&quot;blog/entries.html&quot;, {&#39;entries&#39;: entries}) Make sure to add the template blog/entries.html in your template directory. Run the test again. python manage.py test blog --settings=testcases.test_settings Ran 1 test in 0.019s OK Destroying test database for alias &#39;default&#39;... ###Minor modification to test Since we should not hardcode the urls, we will use reverse. def test_entries_access(self): response = self.c.get(reverse(&#39;entries&#39;)) self.assertEqual(response.status_code, 200) Run the test again to make sure our change has not broken anything. ##Test that context is populated in template We want to make sure that our expectation regarding number of visible blog entries on the page matches the result. Say we have two entries in the database then both of them should be shown on the page as per our view definition. A blog must be associated with a user. So, we will create an instance of user in setUp because we would need this user in other tests as well. def setUp(self): self.c = Client() self.user = User.objects.create_user(username=&quot;test&quot;, email=&quot;test@test.com&quot;, password=&quot;test&quot;) ###Testing the context def test_entries_template_context(self): #create few blog entries BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) response = self.c.get(reverse(&#39;entries&#39;)) #assert that context contains as many entries as you expect self.assertEqual(len(response.context[&#39;entries&#39;]), 2) response contains an attribute context which is a dictionary containing the context sent to template. ###Assertion We created two blogs and asserted that context contains both of them. This test is not much useful now. We will see how response.context becomes useful when we write a custom manager. ##Only logged in user must access create entry page. def test_entry_create(self): response = self.c.get(reverse(&#39;entry_create&#39;)) self.assertEqual(response.status_code, 302) self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) response = self.c.get(reverse(&#39;entry_create&#39;)) self.assertEqual(response.status_code, 200) Run the test. We know it will fail because we have not written the view or the url yet. python manage.py test blog --settings=testcases.test_settings ..... ERROR: test_entry_create (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): .... NoReverseMatch: Reverse for &#39;entry_create&#39; with arguments &#39;()&#39; and keyword arguments &#39;{}&#39; not found. ---------------------------------------------------------------------- Ran 3 tests in 0.051s FAILED (errors=1) ###Explanation: We expect a url with name entry_create to be available. A non-logged user should not be able to access this url and should be redirected to login urll. So, we assert that status code be 302. There is a login method defined on Client. So, we can call self.c.login(). login() takes a username and password. You should provide credentials of some user already present in db. Remember we created an user in setUp. We pass the same credentials here. After this client i.e self.c starts behaving like a logged in user. Now client should be able to access create page and so we assert the status code as 200. Let’s start fixing this test. Need to add following in blog/urls.py url(r&#39;^entry/create/$&#39;, &#39;blog.views.entry_create&#39;, name=&#39;entry_create&#39;), Adding a modelform. This will be used in create view. class BlogEntryForm(ModelForm): class Meta: model = BlogEntry Adding the view def entry_create(request): form = BlogEntryForm() if request.method == &quot;POST&quot;: form = BlogEntryForm(request.POST) if form.is_valid(): return HttpResponseRedirect(reverse(&#39;entries&#39;)) form.save() return render(request, &quot;blog/entry_create.html&quot;, {&#39;form&#39;: form}) Make sure to create the template. And then run the test. You will still see an error. File &quot;/home/akshar/play/dj/testcases/blog/tests.py&quot;, line 30, in test_entry_create self.assertEqual(response.status_code, 302) AssertionError: 200 != 302 Because we missed adding login_required to the view and even anonymous users are able to access this url. And hence they are getting a 200 instead of 302. Let’s fix it by adding login_required decorator to entry_create view. Run the test again and it should pass now. ##Test invalid form So, we wrote entry_create with assumption that it will handle POST requests. We want to make sure that this view doesn’t allow invalid POST and raises an exception in that case. def test_invalid_entry_create(self): self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) data = {&#39;text&#39;: &#39;Test text&#39;} response = self.c.post(reverse(&#39;entry_create&#39;), data) self.assertEqual(response.status_code, 200) self.assertFormError(response, &quot;form&quot;, &quot;title&quot;, &quot;This field is required.&quot;) ###Assertions: Since we posted an invalid form, we expect to remain on the same page. So asserted for status code of 200. We expect an error to be present on the title field. ##Test valid form def test_valid_entry_create(self): self.c.login(username=&#39;test&#39;, password=&#39;test&#39;) data = {&#39;text&#39;: &#39;Test text&#39;, &#39;title&#39;: &#39;Test title&#39;} data[&#39;user&#39;] = self.user.id self.assertEqual(BlogEntry.objects.count(), 0) response = self.c.post(reverse(&#39;entry_create&#39;), data) self.assertEqual(response.status_code, 302) self.assertEqual(BlogEntry.objects.count(), 1) ###Assertions: Before posting we assert that there is no BlogEntry in the db. After posting we check that the user is redirected and so asserted for status code of 302 We make sure that a BlogEntry is created in the database on post by checking that count of BlogEntry has been increased to 1. ##Test custom manager methods Suppose you find yourself writing the same filter multiple times for getting the blog entries which have is_published as True. In that case you would write a custom manager. We will add the custom manager in models.py class PublishedBlogManager(models.Manager): def get_query_set(self, *args, **kwargs): return super(PublishedBlogManager, self).get_query_set(*args, **kwargs).filter(is_published=True) Also we need to add this manager on BlogEntry. So, don’t forget to add next two lines to BlogEntry objects = models.Manager() published = PublishedBlogManager() Let’s write a test now: def test_entry_custom_managers(self): BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user, is_published=False) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) self.assertEqual(BlogEntry.objects.count(), 2) self.assertEqual(BlogEntry.published.count(), 1) ###Assertions: We created two entries. One with is_published as False, and another with True. objects i.e default manager returns all the entries. published i.e custom manager returns only entries which have is_published=True. ###Using custom manager in test_entries_template_context: Say now we decide that all entries should not be shown on list entries page. Only published entries should be shown. Remember test_entries_template_context. We only created two blog entries in that test. Edit that test and create one more entry with is_published=False def test_entries_template_context(self): #create few blog entries BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user) BlogEntry.objects.create(title=&#39;Test&#39;, text=&#39;Test&#39;, user=self.user, is_published=False) response = self.c.get(reverse(&#39;entries&#39;)) #assert that context contains only published entries self.assertEqual(len(response.context[&#39;entries&#39;]), 2) We created three entries. Only two of them are published. ###Assertion: Entries page should only show 2 entries. Run the test and it will fail. ====================================================================== FAIL: test_entries_template_context (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;/home/akshar/play/dj/testcases/blog/tests.py&quot;, line 29, in test_entries_template_context self.assertEqual(len(response.context[&#39;entries&#39;]), 2) AssertionError: 3 != 2 ---------------------------------------------------------------------- Happened because we forgot to change our view. Our view still says BlogEntry.objects.all(). We should change it to BlogEntry.published.all(). Make this change and the test will pass. def entries(request): entries = BlogEntry.published.all() return render_to_response(&quot;blog/entries.html&quot;, {&#39;entries&#39;: entries}) So, response.context helped us find that we do not show more entries than we should. ##Test for pagination Suppose we expect maximum ten entries to be available on each page. There are 15 entries in the db, so first page should show 10 entries and the second page should show 5. If user tries to access the third page a 404 page should be shown. Our decided url pattern for getting entries on a particular page: url(r&#39;^entries/(?P&lt;page&gt;\\d+)/$&#39;, &#39;blog.views.entries_page&#39;, name=&#39;entries_page&#39;) Writing the test: def test_entries_page(self): for i in range(15): BlogEntry.objects.create(title=&quot;title&quot;, text=&quot;text&quot;, user=self.user, is_published=True) #access first page response = self.c.get(reverse(&quot;entries_page&quot;, args=[1,])) self.assertEqual(response.status_code, 200) self.assertEqual(len(response.context[&#39;entries&#39;]), 10) #access second page response = self.c.get(reverse(&quot;entries_page&quot;, args=[2,])) self.assertEqual(response.status_code, 200) self.assertEqual(len(response.context[&#39;entries&#39;]), 5) Run the test and it will fail. Let’s add view to make it pass. def entries_page(request, page): page = int(page) entries = BlogEntry.published.all() paginator = Paginator(entries, 10) #10 entries per page page_ = paginator.page(page) object_list = page_.object_list return render(request, &quot;blog/entries_page.html&quot;, {&quot;entries&quot;: object_list}) Test should pass now provided you have added the template. Let’s try to access third page in the test. We need to add following in test_entries_page for that. #access third page response = self.c.get(reverse(&quot;entries_page&quot;, args=[3,])) self.assertEqual(response.status_code, 404) Running the test raises an error. .... raise EmptyPage(&#39;That page contains no results&#39;) EmptyPage: That page contains no results We find that there is a bug in our view and any page which doesn’t contain entries is not being handled as we want. Let’s change our view: def entries_page(request, page): page = int(page) entries = BlogEntry.published.all() paginator = Paginator(entries, 10) #10 entries per page if page &gt; paginator.num_pages: raise Http404() page_ = paginator.page(page) object_list = page_.object_list return render(request, &quot;blog/entries_page.html&quot;, {&quot;entries&quot;: object_list}) Run the test again. If you have a 404 template defined then your test will pass. In this project we do not have a 404 template and so we get another exception ERROR: test_entries_page (blog.tests.BlogEntriesTest) ---------------------------------------------------------------------- Traceback (most recent call last): .... raise TemplateDoesNotExist(name) TemplateDoesNotExist: 404.html So, let’s add a 404 template. Test passes once we do it. So, this test also helped us find a missing 404 template. ##Test for static files You can look at our blog on static file if you have some confusion regarding how static files are served in Django. We will create a static directory in our app blog and will put an image in this directory. Let’s say this image is default.jpg Let’s add a test to make sure this image is found by django static file handlers. This test makes us confident that we can expect this image to be served at default.jpg from django.contrib.staticfiles import finders from django.contrib.staticfiles.storage import staticfiles_storage def test_images(self): abs_path = finders.find(&#39;default.jpg&#39;) self.assertTrue(staticfiles_storage.exists(abs_path)) Run the test and it should pass. You can view the complete project here.","author":{"@type":"Person","name":"akshar"},"@type":"BlogPosting","url":"http://localhost:4000/testing/2013/04/28/common-testing-scenarios-for-django-app.html","headline":"Common testing scenarios for Django app.","dateModified":"2013-04-28T20:33:38+05:30","datePublished":"2013-04-28T20:33:38+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/testing/2013/04/28/common-testing-scenarios-for-django-app.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="/assets/js/respond.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="/assets/css/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <script>
    	function onPageLoad() {
    		var element = document.getElementById("content");
    		var childNodes = element.childElementCount;
    		if(childNodes > 0) {
    		 	element.scrollIntoView(); 
    	 	}

    	}
    </script>
    
  </head>
  <body onload="onPageLoad()"> 
      <div id="header">
        <nav>
          <li class="fork"><a href="">View On GitHub</a></li>
          <!-- 
            <li class="downloads"><a href="">ZIP</a></li>
            <li class="downloads"><a href="">TAR</a></li>
            <li class="title">DOWNLOADS</li>
           -->
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Agiliq Blogs</h1>
          <!-- <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p> -->
          <hr>
          <span class="credits left">Project maintained by <a href="">Agiliq</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
          <ul>
		  
		  <li>
		    <a href="/python/2018/01/21/prime-number-binary-trex.html" >Finding a prime number whose binary representation is a giraffe (or a T-Rex)</a>
		  </li>
		  
		  <li>
		    <a href="/django/2017/12/29/when-and-how-use-django-listview.html" >When and how to use Django ListView</a>
		  </li>
		  
		  <li>
		    <a href="/django/2017/12/29/when-and-how-use-django-templateview.html" >When and how to use Django TemplateView</a>
		  </li>
		  
		  <li>
		    <a href="/django/2017/12/11/adventures-in-advanced-django-orm-with-hyperloglog.html" >Adventures in advanced Django ORM with HyperLogLog</a>
		  </li>
		  
		  <li>
		    <a href="/django/2017/12/06/django-20-window-expressions-tutorial.html" >Django 2.0 Window expressions tutorial</a>
		  </li>
		  
		  <li>
		    <a href="/django/2017/12/02/configure-django-log-exceptions-production.html" >Configure Django to log exceptions in production</a>
		  </li>
		  
		  <li>
		    <a href="/gunicorn/2017/11/15/how-performant-your-python-web-application.html" >How performant is your Python web application</a>
		  </li>
		  
		  <li>
		    <a href="/python/2017/11/01/how-python-generators-are-similar-iterators.html" >How Python generators are similar to iterators</a>
		  </li>
		  
		  <li>
		    <a href="/python/2017/10/18/real-world-usage-iterators-and-iterables.html" >Real world usage of __iter__ and next</a>
		  </li>
		  
		  <li>
		    <a href="/python/2017/10/12/iterators-and-iterables.html" >Iterators and Iterables</a>
		  </li>
		  
		  <li>
		    <a href="/appengine/2017/09/04/getting-started-webapp2-and-gae.html" >Getting started with webapp2 and GAE</a>
		  </li>
		  
		  <li>
		    <a href="/angularjs/2017/04/30/why-angularjs-services-arent-available-configurati.html" >Why AngularJS services aren't available in configuration blocks</a>
		  </li>
		  
		  <li>
		    <a href="/angularjs/2017/04/27/what-when-and-how-angularjs-configuration-blocks.html" >What, when and how of AngularJS configuration blocks</a>
		  </li>
		  
		  <li>
		    <a href="/2017/04/26/trsfer-files-amzon-s3-using-browser-instead-server.html" >Transfer files to amazon s3 using browser instead of server</a>
		  </li>
		  
		  <li>
		    <a href="/angularjs/2017/04/25/angularjs-injectors-internals.html" >AngularJS injectors internals</a>
		  </li>
		  
		  <li>
		    <a href="/angularjs/2017/04/21/how-script-ordering-works-angular-app.html" >How script ordering works in an Angular app</a>
		  </li>
		  
		  <li>
		    <a href="/scrapy/2016/04/02/getting-started-with-python-scrapy.html" >Getting started with python scrapy</a>
		  </li>
		  
		  <li>
		    <a href="/celery/2015/08/03/retrying-celery-failed-tasks.html" >Retrying celery failed tasks</a>
		  </li>
		  
		  <li>
		    <a href="/middlewares/2015/07/17/profiling-django-middlewares.html" >Profiling Django Middlewares</a>
		  </li>
		  
		  <li>
		    <a href="/middlewares/2015/07/17/understanding-django-middlewares.html" >Understanding Django Middlewares</a>
		  </li>
		  
		  <li>
		    <a href="/redis/2015/07/06/getting-started-with-celery-and-redis.html" >Getting started with Celery and Redis</a>
		  </li>
		  
		  <li>
		    <a href="/django-tastypie/2015/03/29/tastypie-with-foreignkey.html" >Tastypie with ForeignKey</a>
		  </li>
		  
		  <li>
		    <a href="/redis/2015/03/26/getting-started-with-redis-py.html" >Getting started with redis-py</a>
		  </li>
		  
		  <li>
		    <a href="/django-tastypie/2015/03/23/getting-started-with-django-tastypie.html" >Getting started with Django tastypie</a>
		  </li>
		  
		  <li>
		    <a href="/google/2015/03/04/building-chrome-extensions.html" >Building Chrome Extensions</a>
		  </li>
		  
		  <li>
		    <a href="/disqus/2015/01/16/importing-your-old-comments-to-disqus-site.html" >Importing your old comments to Disqus site</a>
		  </li>
		  
		  <li>
		    <a href="/python/2014/12/08/how-not-knowing-encoding-can-trip-you.html" >How not knowing encoding can trip you</a>
		  </li>
		  
		  <li>
		    <a href="/python/2014/12/08/understanding-python-unicode-str-unicodeencodeerro.html" >Understanding Python unicode, str, UnicodeEncodeError and UnicodeDecodeError</a>
		  </li>
		  
		  <li>
		    <a href="/api/2014/12/04/building-a-restful-api-with-django-rest-framework.html" >Building a RESTful API with Django-rest-framework</a>
		  </li>
		  
		  <li>
		    <a href="/encoding/2014/11/19/character-encoding-and-unicode.html" >Character encoding and Unicode</a>
		  </li>
		  
		  <li>
		    <a href="/disqus/2014/11/17/disqus-and-disqus-sso.html" >Disqus and Disqus SSO</a>
		  </li>
		  
		  <li>
		    <a href="/http/client/2014/09/08/using-postman.html" >Using a Postman http client for efficient HTTP testing</a>
		  </li>
		  
		  <li>
		    <a href="/functional-testing/2014/09/02/advanced-functional-testing-with-selenium.html" >Advanced functional testing with Selenium in Django</a>
		  </li>
		  
		  <li>
		    <a href="/functional-testing/2014/09/01/selenium-testing.html" >Introduction to functional testing with Selenium in Django</a>
		  </li>
		  
		  <li>
		    <a href="/coveralls.io/2014/08/22/travis-and-coveralls-for-private-repo.html" >Travis and coveralls for private repo</a>
		  </li>
		  
		  <li>
		    <a href="/django/2014/08/20/django-timezones.html" >Django timezones</a>
		  </li>
		  
		  <li>
		    <a href="/django/app/deployment/2014/08/06/deploying-a-django-app-on-amazon-ec2-instance.html" >Deploying a Django app on Amazon EC2 instance.</a>
		  </li>
		  
		  <li>
		    <a href="/django/2014/08/05/passing-parameters-to-django-admin-action.html" >Passing parameters to Django admin action</a>
		  </li>
		  
		  <li>
		    <a href="/python/2014/07/15/method-decorators-in-python.html" >Method decorators in Python</a>
		  </li>
		  
		  <li>
		    <a href="/gunicorn/2014/06/05/minimal-gunicorn-configuration.html" >Minimal Gunicorn configuration</a>
		  </li>
		  
		  <li>
		    <a href="/heroku/2014/06/05/heroku-django-s3-for-serving-media-files.html" >Heroku Django S3 for serving Media files</a>
		  </li>
		  
		  <li>
		    <a href="/mysqltopostgres/2014/05/27/migrating-django-app-from-mysql-to-postgres.html" >Migrating django app from MySQL to Postgres</a>
		  </li>
		  
		  <li>
		    <a href="/google/2014/05/09/google-diff-match-patch-library.html" >Google diff match patch library</a>
		  </li>
		  
		  <li>
		    <a href="/supervisor/2014/05/09/supervisor-with-django-and-gunicorn.html" >Supervisor with Django and Gunicorn</a>
		  </li>
		  
		  <li>
		    <a href="/python/2014/05/05/python-requests.html" >Python-requests</a>
		  </li>
		  
		  <li>
		    <a href="/python/2014/05/01/three-underutilized-python-commands.html" >Three underutilized python commands</a>
		  </li>
		  
		  <li>
		    <a href="/travis/2014/05/01/continuous-integration-with-travis-and-coverallsio.html" >Continuous integration with travis and coveralls.io for Django apps</a>
		  </li>
		  
		  <li>
		    <a href="/django/2014/04/28/django-backward-relationship-lookup.html" >Django backward relationship lookup</a>
		  </li>
		  
		  <li>
		    <a href="/threads/2013/10/17/producer-consumer-problem-in-python.html" >Producer-consumer problem in Python</a>
		  </li>
		  
		  <li>
		    <a href="/design/pattern/2013/10/14/state-pattern-with-ui-code.html" >State pattern with UI Code</a>
		  </li>
		  
		  <li>
		    <a href="/threads/2013/09/17/understanding-threads-in-python.html" >Understanding Threads in Python</a>
		  </li>
		  
		  <li>
		    <a href="/process/2013/09/11/process-and-threads-for-beginners.html" >Process and Threads for Beginners</a>
		  </li>
		  
		  <li>
		    <a href="/nginx/2013/08/26/minimal-nginx-and-gunicorn-configuration-for-djang.html" >Minimal Nginx and Gunicorn configuration for Django projects</a>
		  </li>
		  
		  <li>
		    <a href="/threads/2013/08/21/writing-thread-safe-django-code.html" >Writing thread-safe django - get_or_create</a>
		  </li>
		  
		  <li>
		    <a href="/python/2013/07/12/accept-bitcoins-using-python.html" >Accept bitcoins using python</a>
		  </li>
		  
		  <li>
		    <a href="/python/2013/07/01/basics-wsgi.html" >Basics of WSGI</a>
		  </li>
		  
		  <li>
		    <a href="/docker/2013/06/28/self-testing-fabfile-using-docker.html" >Self-testing fabfile using docker</a>
		  </li>
		  
		  <li>
		    <a href="/docker/2013/06/14/deploying-django-using-docker.html" >Deploying django using docker</a>
		  </li>
		  
		  <li>
		    <a href="/testing/2013/04/28/common-testing-scenarios-for-django-app.html" >Common testing scenarios for Django app.</a>
		  </li>
		  
		  <li>
		    <a href="/static/2013/03/21/serving-static-files-in-django.html" >Serving static files in Django</a>
		  </li>
		  
		  <li>
		    <a href="/book/2013/02/11/two-scoops-of-django-review.html" >Two Scoops of Django: Review</a>
		  </li>
		  
		  <li>
		    <a href="/training/2013/02/08/introduction-to-python-workshop-on-february-15th-2.html" >Introduction to Python Workshop on February 15th, 2013</a>
		  </li>
		  
		  <li>
		    <a href="/django/2013/02/07/easy-client-side-form-validations-for-django-djang.html" >Easy client side form validations for Django: Django Parsley</a>
		  </li>
		  
		  <li>
		    <a href="/open-source/2013/01/21/moreapps-android-library-project-open-sourced.html" >MoreApps - Android Library Project: Open Sourced</a>
		  </li>
		  
		  <li>
		    <a href="/open-source/2013/01/15/password-generetor-app-open-sourced.html" >Password Generator App: Open Sourced</a>
		  </li>
		  
		  <li>
		    <a href="/open-source/2013/01/14/todo-list-app-open-sourced.html" >Todo List App: Open Sourced</a>
		  </li>
		  
		  <li>
		    <a href="/android/2013/01/01/android-fragments-101.html" >Android Fragments 101</a>
		  </li>
		  
		  <li>
		    <a href="/function/as/objects/2012/11/17/understanding-decorators-2.html" >Understanding decorators</a>
		  </li>
		  
		  <li>
		    <a href="/forms/2012/11/07/not-exactly-not-exactly-tim-the-enchanter.html" >Not exactly, not exactly tim the enchanter</a>
		  </li>
		  
		  <li>
		    <a href="/internals/2012/11/01/the-missing-documentation-for-djangoutilsdatastruc.html" >The missing documentation for django.utils.datastructures</a>
		  </li>
		  
		  <li>
		    <a href="/2012/09/06/dissecting-phonegaps-architecture.html" >Dissecting Phonegaps Architecture</a>
		  </li>
		  
		  <li>
		    <a href="/upload/2012/07/17/dropbox-file-upload-handler-for-django.html" >Dropbox file upload handler for django</a>
		  </li>
		  
		  <li>
		    <a href="/virtualization/2012/07/16/using-ubuntu-cloud-images-in-kvm.html" >Using Ubuntu cloud images in KVM</a>
		  </li>
		  
		  <li>
		    <a href="/metaclass/2012/07/02/metaclass-python.html" >Metaclass in Python</a>
		  </li>
		  
		  <li>
		    <a href="/virtualization/2012/06/25/libvirt-and-kvm.html" >Libvirt and KVM</a>
		  </li>
		  
		  <li>
		    <a href="/__new__/2012/06/10/__new__-python.html" >__new__() in python</a>
		  </li>
		  
		  <li>
		    <a href="/kwargs/2012/06/03/understanding-args-and-kwargs.html" >Understanding '*', '*args', '**' and '**kwargs'</a>
		  </li>
		  
		  <li>
		    <a href="/provisioning/2012/05/29/provisioning-made-easy-with-chef.html" >Provisioning Made Easy With Chef</a>
		  </li>
		  
		  <li>
		    <a href="/development/2012/05/02/test-driven-development-python.html" >Test Driven Development in Python </a>
		  </li>
		  
		  <li>
		    <a href="/terminal/2012/03/20/developing-android-applications-from-command-line.html" >Developing android applications from command line</a>
		  </li>
		  
		  <li>
		    <a href="/vps/2012/02/23/deploy-django-app-5-easy-steps.html" >Deploy Django App in 5 Easy Steps</a>
		  </li>
		  
		  <li>
		    <a href="/django/2012/02/22/deploying-django-apps-on-heroku.html" >Deploying Django apps on Heroku</a>
		  </li>
		  
		  <li>
		    <a href="/site_id/prefix/2012/02/05/dynamically-attaching-site_id-django-caching.html" > Dynamically attaching SITE_ID to Django Caching</a>
		  </li>
		  
		  <li>
		    <a href="/django/2012/02/04/deploying-django-apps-on-heroku-2.html" >Deploying Django apps on Heroku</a>
		  </li>
		  
		  <li>
		    <a href="/screencasts/2012/02/03/how-to-use-pep8py-to-write-better-django-code.html" >How to use pep8.py to write better Django code</a>
		  </li>
		  
		  <li>
		    <a href="/screencasts/2012/02/02/how-and-why-to-use-pyflakes-to-write-better-python.html" >How and why to use pyflakes to write better Python</a>
		  </li>
		  
		  <li>
		    <a href="/south/2012/01/09/south.html" >Getting started with South for Django DB migrations</a>
		  </li>
		  
		  <li>
		    <a href="/coffeescript/2012/01/06/writing-jquery-plugins-using-coffeescript.html" >Writing jQuery plugins using Coffeescript</a>
		  </li>
		  
		  <li>
		    <a href="/response/2012/01/02/behind-the-scenes-request-to-response.html" >Request to Response</a>
		  </li>
		  
		  <li>
		    <a href="/java/2011/12/28/using-sqlite-database-with-android.html" >Using SQLite Database with Android</a>
		  </li>
		  
		  <li>
		    <a href="/django/2011/12/25/haml-for-django-developers.html" >Haml for Django developers</a>
		  </li>
		  
		  <li>
		    <a href="/coffeescript/2011/12/24/coffeescript-for-python-programmers.html" >Coffeescript for Python programmers</a>
		  </li>
		  
		  <li>
		    <a href="/treeview/2011/10/12/how-use-jstree.html" >How to use jsTree</a>
		  </li>
		  
		  <li>
		    <a href="/upload/2011/09/21/behind-the-scenes-from-html-form-to-storage.html" >From HTML Form to Storage</a>
		  </li>
		  
		  <li>
		    <a href="/mysql/2011/07/01/setting-your-system-start-django-development-ubunt.html" >Setting up your system to start with Django development on Ubuntu:</a>
		  </li>
		  
		  <li>
		    <a href="/e-mail/2011/04/05/writing-an-e-mail-application-with-lamson-ii.html" >Writing an e-mail application with Lamson - II</a>
		  </li>
		  
		  <li>
		    <a href="/e-mail/2011/04/01/writing-an-e-mail-application-with-lamson-i.html" >Writing an e-mail application with Lamson - I</a>
		  </li>
		  
		  <li>
		    <a href="/jobs/2011/03/15/jobs.html" >Jobs</a>
		  </li>
		  
		  <li>
		    <a href="/java/2011/02/08/comparision-iphone-android-phonegap-titanium.html" >Comparison of mobile app frameworks: Iphone, Java, Phonegap and Titanium</a>
		  </li>
		  
		  <li>
		    <a href="/iphone/2011/02/08/getting-started-with-titanium-development.html" >Getting started with Titanium development for Android and Iphone</a>
		  </li>
		  
		  <li>
		    <a href="/android/2011/02/06/getting-started-with-phonegap-using-xcode-for-mobi.html" >Getting started with PhoneGap using Xcode for Mobile app development</a>
		  </li>
		  
		  <li>
		    <a href="/java/2011/02/06/starting-android-app-developement-from-zero-to-app.html" >Starting Android app developement: From zero to app</a>
		  </li>
		  
		  <li>
		    <a href="/mobile/applications/2011/02/03/iphoneandroid-application-development-using-titani.html" >iPhone and Android application development using Titanium</a>
		  </li>
		  
		  <li>
		    <a href="/linkroundup/2011/01/21/link-roundup-10.html" >Link roundup 10</a>
		  </li>
		  
		  <li>
		    <a href="/linkroundup/2011/01/07/link-roundup-9.html" >Link roundup 9</a>
		  </li>
		  
		  <li>
		    <a href="/reviews/2010/12/31/book-review-the-principles-of-beautiful-web-design.html" >Book Review: The Principles Of Beautiful Web Design</a>
		  </li>
		  
		  <li>
		    <a href="/linkroundup/2010/12/31/link-roundup-8.html" >Link roundup 8</a>
		  </li>
		  
		  <li>
		    <a href="/emacs/2010/12/27/django-emacs-setup.html" >Django emacs setup</a>
		  </li>
		  
		  <li>
		    <a href="/reviews/2010/12/26/book-review-pragmatic-guide-to-javascript.html" >Book Review: Pragmatic Guide to JavaScript</a>
		  </li>
		  
		  <li>
		    <a href="/reviews/2010/12/25/the-principles-of-successful-freelancing.html" >Book review: The Principles of Successful Freelancing</a>
		  </li>
		  
		  <li>
		    <a href="/reviews/2010/12/24/book-review-the-principles-of-project-management.html" >Book review: The Principles of Project Management</a>
		  </li>
		  
		  <li>
		    <a href="/reviews/2010/12/24/book-review-outsourcing-web-projects.html" >Book Review: Outsourcing Web Projects.</a>
		  </li>
		  
		  <li>
		    <a href="/linkroundup/2010/12/23/link-roundup-for-week-ending-24122010.html" >Link roundup for week ending 24/12/2010</a>
		  </li>
		  
		  <li>
		    <a href="/%0A2010-12-22-real-time-applications-with-django-xmpp-and-stroph.markdown/xmpp/2010/12/22/real-time-applications-with-django-xmpp-and-stroph.html" >Real time applications with Django, XMPP and StropheJS</a>
		  </li>
		  
		  <li>
		    <a href="/tips/2010/12/04/the-unfuddle-tutorial.html" >The Unfuddle Tutorial</a>
		  </li>
		  
		  <li>
		    <a href="/apps/2010/12/04/experiments-in-url-design.html" >Experiments in URL design.</a>
		  </li>
		  
		  <li>
		    <a href="/linkroundup/2010/11/26/link-roundup-for-week-ending-26112010.html" >Link roundup for week ending 26/11/2010</a>
		  </li>
		  
		  <li>
		    <a href="/linkroundup/2010/11/19/link-roundup-for-week-ending-19112010.html" >Link Roundup for week ending 19/11/2010</a>
		  </li>
		  
		  <li>
		    <a href="/linkroundup/2010/11/12/link-roundup-for-week-ending-12112010.html" >Link Roundup for week ending 12/11/2010</a>
		  </li>
		  
		  <li>
		    <a href="/python/2010/11/07/i-am-so-starving-same-web-app-in-various-python-we.html" >I am so starving: Web app in python frameworks.</a>
		  </li>
		  
		  <li>
		    <a href="/vim/2010/11/03/seven-reasons-why-you-should-switch-to-vim-for-dja.html" >Seven reasons why you should switch to Vim</a>
		  </li>
		  
		  <li>
		    <a href="/linkroundup/2010/11/03/link-roundup-for-week-ending-5112011.html" >Link Roundup for week ending 5/11/2011</a>
		  </li>
		  
		  <li>
		    <a href="/wordpress/2010/10/28/importing-wordpress.html" >Importing wordpress</a>
		  </li>
		  
		  <li>
		    <a href="/api/2010/10/25/getting-trending-github-projects-via.html" >Getting trending Github projects via YQL</a>
		  </li>
		  
		  <li>
		    <a href="/linkroundup/2010/10/22/link-roundup-for-week-ending-2.html" >Link Roundup for week ending 22/10/2010</a>
		  </li>
		  
		  <li>
		    <a href="/business/2010/10/18/essential-web-apps-to-run-a.html" >Essential web-apps to run a software business.</a>
		  </li>
		  
		  <li>
		    <a href="/opinion/2010/10/17/django-is-not-flexible.html" >Django is not flexible</a>
		  </li>
		  
		  <li>
		    <a href="/linkroundup/2010/10/15/link-roundup-for-week-ending.html" >Link Roundup for week ending 15/10/2010</a>
		  </li>
		  
		  <li>
		    <a href="/about/2010/06/08/moving-home.html" >Moving home</a>
		  </li>
		  
		  <li>
		    <a href="/uncategorized/2010/03/20/rails-and-django-commands-comparison-and-conversio.html" >Rails and Django commands : comparison  and conversion</a>
		  </li>
		  
		  <li>
		    <a href="/rails/2010/03/20/the-rails-and-django-models-layer-rosseta-stone.html" >The Rails and Django models layer Rosseta stone</a>
		  </li>
		  
		  <li>
		    <a href="/models/2010/01/18/doing-things-with-django-models-aka-django-models.html" >Doing things with Django models - aka - Django models tutorial</a>
		  </li>
		  
		  <li>
		    <a href="/about/2010/01/17/wordpress-and-django-best-buddies.html" >Wordpress and Django: best buddies</a>
		  </li>
		  
		  <li>
		    <a href="/tutorial/2010/01/14/doing-things-with-django-forms.html" >Doing things with Django forms</a>
		  </li>
		  
		  <li>
		    <a href="/apps/2010/01/07/django-forum.html" >django-forum</a>
		  </li>
		  
		  <li>
		    <a href="/uncategorized/2009/12/13/django-buzz.html" >Django-buzz</a>
		  </li>
		  
		  <li>
		    <a href="/tutorial/2009/12/12/using-bpython-shell-with-django-and-some-ipython-f.html" >Using bpython shell with django (and some Ipython features you should know)</a>
		  </li>
		  
		  <li>
		    <a href="/india/2009/12/10/fossin-2009-the-best-fossin-ever.html" >Foss.in 2009: The best foss.in. Ever. </a>
		  </li>
		  
		  <li>
		    <a href="/tutorial/2009/12/03/python-metaclasses-and-how-django-uses-them.html" >Python metaclasses and how Django uses them</a>
		  </li>
		  
		  <li>
		    <a href="/django/2009/12/03/django-quiz.html" >Django quiz</a>
		  </li>
		  
		  <li>
		    <a href="/python/2009/11/26/django-for-a-rails-developer.html" >Django for a Rails Developer</a>
		  </li>
		  
		  <li>
		    <a href="/uncategorized/2009/11/21/the-magic-of-metaclasses-in-python.html" >The magic of metaclasses in Python</a>
		  </li>
		  
		  <li>
		    <a href="/tutorial/2009/11/21/writing-your-own-template-loaders.html" >Writing your own template loaders</a>
		  </li>
		  
		  <li>
		    <a href="/tutorial/2009/11/11/django-gotchas.html" >Django gotchas </a>
		  </li>
		  
		  <li>
		    <a href="/uncategorized/2009/10/02/pycon-india-2009-a-review.html" >Pycon India 2009 : A Review</a>
		  </li>
		  
		  <li>
		    <a href="/tutorial/2009/09/18/beginning-python.html" >Beginning python</a>
		  </li>
		  
		  <li>
		    <a href="/yahoo/2009/08/27/django-socialauth-login-via-twitter-facebook-openi.html" >Django-SocialAuth - Login via twitter, facebook, openid, yahoo, google using a single app.</a>
		  </li>
		  
		  <li>
		    <a href="/rambling/2009/08/20/a-response-to-dropping-django.html" >A response to Dropping Django</a>
		  </li>
		  
		  <li>
		    <a href="/aggreagtion/2009/08/18/django-aggregation-tutorial.html" >Django aggregation tutorial</a>
		  </li>
		  
		  <li>
		    <a href="/tips/2009/07/16/on-captcha.html" >On Captcha</a>
		  </li>
		  
		  <li>
		    <a href="/book/2009/07/03/django-design-patterns.html" >Django design patterns</a>
		  </li>
		  
		  <li>
		    <a href="/django/2009/07/02/remote-debugging-debugging-pesky-server-only-bugs.html" >Remote debugging - debugging pesky server only bugs</a>
		  </li>
		  
		  <li>
		    <a href="/django/2009/06/25/django-request-response-processing.html" >Django Request Response processing</a>
		  </li>
		  
		  <li>
		    <a href="/python/2009/06/24/better-python-package-management-using-source-and.html" >Better Python package management using source and version control systems</a>
		  </li>
		  
		  <li>
		    <a href="/python/2009/06/23/understanding-decorators.html" >Understanding decorators</a>
		  </li>
		  
		  <li>
		    <a href="/algorithms/2009/06/16/generating-pseudo-random-text-with-markov-chains-u.html" >Generating pseudo random text with Markov chains using Python</a>
		  </li>
		  
		  <li>
		    <a href="/yahoo/2009/06/14/yahoo-boss-python-api.html" >Yahoo BOSS python api</a>
		  </li>
		  
		  <li>
		    <a href="/api/2009/06/10/python-wrapper-on-bing-api.html" >Python Wrapper on Bing API</a>
		  </li>
		  
		  <li>
		    <a href="/ecommerce/2009/03/31/exploring-authorizenet-payment-gateway-options-and.html" >Exploring Authorize.net Payment Gateway Options and integrating it with django</a>
		  </li>
		  
		  <li>
		    <a href="/satchmo/2009/03/26/create-your-own-online-store-in-few-hours-using-sa.html" >Create your own online store in few hours using satchmo (django)</a>
		  </li>
		  
		  <li>
		    <a href="/pinax/2009/03/18/create-a-new-social-networking-site-in-few-hours-u.html" >Create a new social networking site in few hours using pinax platform (django).</a>
		  </li>
		  
		  <li>
		    <a href="/uncategorized/2009/03/11/uswaretech-whitepapers.html" >Uswaretech whitepapers</a>
		  </li>
		  
		  <li>
		    <a href="/products/2009/03/11/django-subdomains-easily-create-subscription-based.html" >Django-subdomains - Easily create subscription based subdomains enabled webapps</a>
		  </li>
		  
		  <li>
		    <a href="/algorithms/2009/03/09/finding-keywords-using-python.html" >Finding keywords using Python</a>
		  </li>
		  
		  <li>
		    <a href="/business/2009/03/09/web-development-companies-working-with-django.html" >Web development companies working with Django</a>
		  </li>
		  
		  <li>
		    <a href="/presentations/2009/03/08/developing-a-web-application-live-in-15-min-in-dja.html" > Developing a Web Application Live in 15 min, in django framework</a>
		  </li>
		  
		  <li>
		    <a href="/algorithms/2009/03/06/constraint-programming-in-python.html" >Constraint programming in Python</a>
		  </li>
		  
		  <li>
		    <a href="/mysql/2009/03/06/django-with-mysql-and-apache-on-ec2.html" >Django with Mysql and Apache on EC2</a>
		  </li>
		  
		  <li>
		    <a href="/facebook/2009/02/20/how-to-build-a-facebook-app-in-django.html" >How to build a Facebook app in Django</a>
		  </li>
		  
		  <li>
		    <a href="/web2.0/2009/02/19/how-we-built-a-twitter-application.html" >How we built a Twitter Application</a>
		  </li>
		  
		  <li>
		    <a href="/paypal/2008/11/12/using-paypal-with-django.html" >Using Paypal with Django</a>
		  </li>
		  
		  <li>
		    <a href="/tips/2008/10/10/using-subdomains-with-django.html" >Using subdomains with Django</a>
		  </li>
		  
		  <li>
		    <a href="/forms/2008/10/10/dynamic-forms-with-django.html" >Dynamic forms with Django</a>
		  </li>
		  
		  <li>
		    <a href="/tips/2008/10/07/generating-pdfs-with-django.html" >Generating PDFs with Django </a>
		  </li>
		  
		  <li>
		    <a href="/interviews/2008/06/24/an-interview-with-adrian-holovaty-creator-of-djang.html" >An Interview with Adrian Holovaty - Creator of Django</a>
		  </li>
		  
		  <li>
		    <a href="/python/2008/05/30/an-interview-with-jacob-kaplan-moss-creator-of-dja.html" >An Interview with Jacob Kaplan-Moss - Creator of Django</a>
		  </li>
		  
		  <li>
		    <a href="/startup/2008/05/14/an-idea-a-day-a-geographical-wiki.html" >An idea a day - A geographical wiki</a>
		  </li>
		  
		  <li>
		    <a href="/startup/2008/05/13/an-idea-a-day-alternative-to-gae.html" >An idea a day - Alternative to GAE</a>
		  </li>
		  
		  <li>
		    <a href="/startup/2008/05/12/an-idea-a-day-remotely-hosted-analytics-solution.html" >An idea a day - Remotely hosted Analytics solution</a>
		  </li>
		  
		  <li>
		    <a href="/uncategorized/2008/05/12/popularising-django-part-2.html" >Popularising Django - Part 2</a>
		  </li>
		  
		  <li>
		    <a href="/startup/2008/05/11/an-idea-a-day-recomendation-system-based-ad-networ.html" >An idea a day - Recomendation system based ad network</a>
		  </li>
		  
		  <li>
		    <a href="/startup/2008/05/10/an-idea-a-day-an-automated-adwords-optimizer.html" >An idea a day - An automated Adwords optimizer</a>
		  </li>
		  
		  <li>
		    <a href="/search/2008/05/08/parable-of-the-single-sheep-or-how-google-is-destr.html" >Parable of the single sheep - Or How Google is destroying the internet, and nobody seems to know.</a>
		  </li>
		  
		  <li>
		    <a href="/marketing/2008/05/06/an-interview-with-michael-trier.html" >An interview with Michael Trier</a>
		  </li>
		  
		  <li>
		    <a href="/marketing/2008/05/06/popularizing-django-or-reusable-apps-considered-ha.html" >Popularizing Django -- Or Reusable apps considered harmful.</a>
		  </li>
		  
		  <li>
		    <a href="/interviews/2008/04/27/interview-with-james-bennett-django-release-manage.html" >Interview with James Bennett - Django release manager</a>
		  </li>
		  
		  <li>
		    <a href="/search/2008/04/22/parable-of-the-nofollow.html" >Parable of the nofollow</a>
		  </li>
		  
		  <li>
		    <a href="/startup/2008/04/22/why-people-start-startups.html" >Why people start startups.</a>
		  </li>
		  
		  <li>
		    <a href="/marketing/2008/04/21/marketing-lessons-from-google.html" >Marketing lessons from Google</a>
		  </li>
		  
		  <li>
		    <a href="/python/2008/04/18/five-things-i-hate-about-django.html" >Five Things I Hate About Django.</a>
		  </li>
		  
		  <li>
		    <a href="/startup/2008/04/12/first-step-to-startup-getting-your-pitch.html" >First step to startup - Getting your pitch</a>
		  </li>
		  
		  <li>
		    <a href="/python/2008/04/11/two-djangoappengine-tutorials.html" >Two Django+Appengine Tutorials</a>
		  </li>
		  
		  <li>
		    <a href="/python/2008/04/09/using-appengine-with-django-why-it-is-pretty-much.html" >Using Appengine with Django, why it is pretty much unusable</a>
		  </li>
		  
		  <li>
		    <a href="/python/2008/04/09/google-appengine-first-impressions.html" >Google Appengine - First Impressions</a>
		  </li>
		  
		</ul>
        </div>
        
        
        
      </section>
      <div id="content">
     	<p>People are often confused regarding what tests to write. Let’s look into some scenarios for which tests can be written.</p>

<p>##Setting up the project</p>

<p>We start a Django project inside a virtual environment. In this post we would be using django 1.4.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(dj)~/play/dj$ django-admin.py startproject testcases
</code></pre></div></div>

<p>Let’s start an app named <code class="highlighter-rouge">blog</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(dj)~/play/dj/testcases$ python manage.py startapp blog
</code></pre></div></div>

<p>We will have the following model in <code class="highlighter-rouge">blog/models.py</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class BlogEntry(models.Model):
    title = models.CharField(max_length=100)
    text = models.TextField()
    is_published = models.BooleanField(default=True)
    user = models.ForeignKey(User)
</code></pre></div></div>

<p>We will do test driven development which requires:</p>

<ul>
  <li>Thinking about our assumption.</li>
  <li>Writing the test to satisfy that assumption.</li>
  <li>Run the test and it will fail since we won’t have view written till this point.</li>
  <li>Adding the view.</li>
  <li>Run the test and fixing the view or anything else till our test passes.</li>
</ul>

<p>If I could not explain the project structure properly, you can find the complete project <a href="https://github.com/akshar-raaj/Testing-in-Django">here</a>.</p>

<p>##First test</p>

<p>We want a page which shows all blog entries at url <code class="highlighter-rouge">/blog/entries/</code>.</p>

<p>We need following line in urls i.e <code class="highlighter-rouge">testcases/urls.py</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>url(r'^blog/', include('blog.urls')),
</code></pre></div></div>

<p><code class="highlighter-rouge">blog/urls.py</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>url(r'^entries/$', 'blog.views.entries', name='entries'),
</code></pre></div></div>

<p>Let’s add a test which satisfies our assumption.</p>

<p>Every app we create gets a <code class="highlighter-rouge">tests.py</code> where we can put our tests. You can remove the simple addition test generated by default by Django.</p>

<p><code class="highlighter-rouge">blog/tests.py</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from django.test import TestCase
from django.test.client import Client

class BlogEntriesTest(TestCase):

    def setUp(self):
        self.c = Client()

    def test_entries_access(self):
        response = self.c.get('/blog/entries/')
        self.assertEqual(response.status_code, 200)
</code></pre></div></div>

<p>###Explanation</p>

<ul>
  <li>We need a test class which is <code class="highlighter-rouge">BlogEntriesTest</code>. Any test class we write must subclass <strong>TestCase</strong> which is defined in <code class="highlighter-rouge">django.test</code>.</li>
  <li>Actual tests go in methods defined on the test class. So, our test goes in <code class="highlighter-rouge">test_entries_access</code>. Every test method name must start with <strong>test</strong> for it to be found by the django test runner.</li>
  <li>Before every test, <code class="highlighter-rouge">setUp</code> method is run. So anything which is common on all the test methods can go in <code class="highlighter-rouge">setUp</code>.</li>
  <li>We created a <code class="highlighter-rouge">Client</code> object in setUp. This object is needed to make <code class="highlighter-rouge">GET</code> or <code class="highlighter-rouge">POST</code> request. <code class="highlighter-rouge">Client</code> object simulates request to a url similar to a browser can. Since it is created in setUp, it will be available in all the test methods.</li>
  <li>From <code class="highlighter-rouge">test_entries_access</code>, we make a GET request to the url which we have defined. We capture the response in variable <strong>response</strong>.</li>
  <li>We are asserting that <code class="highlighter-rouge">status_code</code> of response must be 200 since we assumed this url to return a 200.</li>
</ul>

<p>###Running the test
Tests use a database. Since sqlite is faster than mysql or postgresql, we would use sqlite as the test database. You can continue using your any other database for development or production. We are only interested in running the tests using sqlite.</p>

<p><code class="highlighter-rouge">testcases/test_settings.py</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from settings import *
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'abc'
     }
}
</code></pre></div></div>

<p>Running the test.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python manage.py test blog --settings=testcases.test_settings
</code></pre></div></div>

<p><code class="highlighter-rouge">blog</code> says that only run the tests for app <code class="highlighter-rouge">blog</code>. Not providing this would run the tests for all the apps defined in INSTALLED_APPS which would take quite some time. Make sure that you have added <code class="highlighter-rouge">blog</code> to INSTALLED_APPS.</p>

<p><code class="highlighter-rouge">--settings</code> flag tells django test runner to use the specified settings file.</p>

<p><strong>And our test fails.</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERROR: test_entries_access (blog.tests.BlogEntriesTest)
----------------------------------------------------------------------
Traceback (most recent call last):
......
......
ViewDoesNotExist: Could not import blog.views.entries. View does not exist in module blog.views.

----------------------------------------------------------------------
Ran 1 test in 0.019s

FAILED (errors=1)
</code></pre></div></div>

<p>Because we have not written the view yet. We didn’t have to go to browser to check if this url works, our test does it for us.</p>

<p>We should test every url we want available in our project. So, that if some url breaks our test would tell that to us immediately.</p>

<p>###Adding the view</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from blog.models import BlogEntry
from django.shortcuts import render

def entries(request):
    entries = BlogEntry.objects.all()
    return render("blog/entries.html", {'entries': entries})
</code></pre></div></div>

<p>Make sure to add the template <code class="highlighter-rouge">blog/entries.html</code> in your template directory.</p>

<p>Run the test again.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python manage.py test blog --settings=testcases.test_settings

Ran 1 test in 0.019s

OK
Destroying test database for alias 'default'...
</code></pre></div></div>

<p>###Minor modification to test</p>

<p>Since we should not hardcode the urls, we will use <code class="highlighter-rouge">reverse</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_entries_access(self):
    response = self.c.get(reverse('entries'))
    self.assertEqual(response.status_code, 200)
</code></pre></div></div>

<p>Run the test again to make sure our change has not broken anything.</p>

<p>##Test that context is populated in template</p>

<p>We want to make sure that our expectation regarding number of visible blog entries on the page matches the result. Say we have two entries in the database then both of them should be shown on the page as per our view definition.</p>

<p>A blog must be associated with a user. So, we will create an instance of user in <code class="highlighter-rouge">setUp</code> because we would need this user in other tests as well.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def setUp(self):
    self.c = Client()
    self.user = User.objects.create_user(username="test", email="test@test.com", password="test")
</code></pre></div></div>

<p>###Testing the context</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_entries_template_context(self):
    #create few blog entries
    BlogEntry.objects.create(title='Test', text='Test', user=self.user)
    BlogEntry.objects.create(title='Test', text='Test', user=self.user)

    response = self.c.get(reverse('entries'))
    #assert that context contains as many entries as you expect
    self.assertEqual(len(response.context['entries']), 2)
</code></pre></div></div>

<p><code class="highlighter-rouge">response</code> contains an attribute <strong>context</strong> which is a dictionary containing the context sent to template.</p>

<p>###Assertion</p>
<ul>
  <li>We created two blogs and asserted that context contains both of them.</li>
</ul>

<p>This test is not much useful now. We will see how <code class="highlighter-rouge">response.context</code> becomes useful when we write a custom manager.</p>

<p>##Only logged in user must access create entry page.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_entry_create(self):
    response = self.c.get(reverse('entry_create'))
    self.assertEqual(response.status_code, 302)

    self.c.login(username='test', password='test')
    response = self.c.get(reverse('entry_create'))
    self.assertEqual(response.status_code, 200)
</code></pre></div></div>

<p>Run the test. We know it will fail because we have not written the view or the url yet.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python manage.py test blog --settings=testcases.test_settings

.....
ERROR: test_entry_create (blog.tests.BlogEntriesTest)
----------------------------------------------------------------------
Traceback (most recent call last):
....
NoReverseMatch: Reverse for 'entry_create' with arguments '()' and keyword arguments '{}' not found.
----------------------------------------------------------------------
Ran 3 tests in 0.051s

FAILED (errors=1)
</code></pre></div></div>

<p>###Explanation:</p>
<ul>
  <li>We expect a url with name <code class="highlighter-rouge">entry_create</code> to be available.</li>
  <li>A non-logged user should not be able to access this url and should be redirected to login urll. So, we assert that status code be 302.</li>
  <li>There is a <code class="highlighter-rouge">login</code> method defined on <code class="highlighter-rouge">Client</code>. So, we can call <code class="highlighter-rouge">self.c.login()</code>.</li>
  <li><code class="highlighter-rouge">login()</code> takes a username and password. You should provide credentials of some user already present in db. Remember we created an user in <code class="highlighter-rouge">setUp</code>. We pass the same credentials here.</li>
  <li>After this client i.e <code class="highlighter-rouge">self.c</code> starts behaving like a logged in user.</li>
  <li>Now client should be able to access create page and so we assert the status code as 200.</li>
</ul>

<p>Let’s start fixing this test.</p>

<p>Need to add following in <code class="highlighter-rouge">blog/urls.py</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>url(r'^entry/create/$', 'blog.views.entry_create', name='entry_create'),
</code></pre></div></div>

<p>Adding a modelform. This will be used in create view.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">class</span> <span class="n">BlogEntryForm</span><span class="p">(</span><span class="n">ModelForm</span><span class="p">):</span>                                                                          
    <span class="n">class</span> <span class="n">Meta</span><span class="p">:</span>
        <span class="k">model</span> <span class="p">=</span> <span class="n">BlogEntry</span>
</code></pre></div></div>

<p>Adding the view</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def entry_create(request):
    form = BlogEntryForm()
    if request.method == "POST":
        form = BlogEntryForm(request.POST)
        if form.is_valid():
            return HttpResponseRedirect(reverse('entries'))
            form.save()
    return render(request, "blog/entry_create.html", {'form': form})
</code></pre></div></div>

<p>Make sure to create the template. And then run the test.</p>

<p>You will still see an error.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>File "/home/akshar/play/dj/testcases/blog/tests.py", line 30, in test_entry_create
    self.assertEqual(response.status_code, 302)
AssertionError: 200 != 302
</code></pre></div></div>

<p>Because we missed adding <code class="highlighter-rouge">login_required</code> to the view and even anonymous users are able to access this url. And hence they are getting a 200 instead of 302.</p>

<p>Let’s fix it by adding <code class="highlighter-rouge">login_required</code> decorator to <code class="highlighter-rouge">entry_create</code> view.</p>

<p>Run the test again and it should pass now.</p>

<p>##Test invalid form</p>

<p>So, we wrote <code class="highlighter-rouge">entry_create</code> with assumption that it will handle POST requests.</p>

<p>We want to make sure that this view doesn’t allow invalid POST and raises an exception in that case.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_invalid_entry_create(self):
    self.c.login(username='test', password='test')
    data = {'text': 'Test text'}
    response = self.c.post(reverse('entry_create'), data)
    self.assertEqual(response.status_code, 200)
    self.assertFormError(response, "form", "title", "This field is required.")
</code></pre></div></div>

<p>###Assertions:</p>

<ul>
  <li>Since we posted an invalid form, we expect to remain on the same page. So asserted for status code of 200.</li>
  <li>We expect an error to be present on the <code class="highlighter-rouge">title</code> field.</li>
</ul>

<p>##Test valid form</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_valid_entry_create(self):
    self.c.login(username='test', password='test')
    data = {'text': 'Test text', 'title': 'Test title'}
    data['user'] = self.user.id
    self.assertEqual(BlogEntry.objects.count(), 0)
    response = self.c.post(reverse('entry_create'), data)
    self.assertEqual(response.status_code, 302)
    self.assertEqual(BlogEntry.objects.count(), 1)
</code></pre></div></div>

<p>###Assertions:</p>

<ul>
  <li>Before posting we assert that there is no <code class="highlighter-rouge">BlogEntry</code> in the db.</li>
  <li>After posting we check that the user is redirected and so asserted for status code of 302</li>
  <li>We make sure that a <code class="highlighter-rouge">BlogEntry</code> is created in the database on post by checking that count of <code class="highlighter-rouge">BlogEntry</code> has been increased to 1.</li>
</ul>

<p>##Test custom manager methods</p>

<p>Suppose you find yourself writing the same filter multiple times for getting the blog entries which have is_published as True. In that case you would write a custom manager.</p>

<p>We will add the custom manager in models.py</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class PublishedBlogManager(models.Manager):
    def get_query_set(self, *args, **kwargs):
        return super(PublishedBlogManager, self).get_query_set(*args, **kwargs).filter(is_published=True)
</code></pre></div></div>

<p>Also we need to add this manager on <code class="highlighter-rouge">BlogEntry</code>. So, don’t forget to add next two lines to <code class="highlighter-rouge">BlogEntry</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>objects = models.Manager()
published = PublishedBlogManager()
</code></pre></div></div>

<p>Let’s write a test now:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_entry_custom_managers(self):
    BlogEntry.objects.create(title='Test', text='Test', user=self.user, is_published=False)
    BlogEntry.objects.create(title='Test', text='Test', user=self.user)
    self.assertEqual(BlogEntry.objects.count(), 2)
    self.assertEqual(BlogEntry.published.count(), 1)
</code></pre></div></div>

<p>###Assertions:</p>

<ul>
  <li>We created two entries. One with is_published as False, and another with True.</li>
  <li><code class="highlighter-rouge">objects</code> i.e default manager returns all the entries.</li>
  <li><code class="highlighter-rouge">published</code> i.e custom manager returns only entries which have <code class="highlighter-rouge">is_published=True</code>.</li>
</ul>

<p>###Using custom manager in <strong>test_entries_template_context</strong>:</p>

<p>Say now we decide that all entries should not be shown on list entries page. Only published entries should be shown.</p>

<p>Remember <code class="highlighter-rouge">test_entries_template_context</code>. We only created two blog entries in that test. Edit that test and create one more entry with <code class="highlighter-rouge">is_published=False</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_entries_template_context(self):
    #create few blog entries
    BlogEntry.objects.create(title='Test', text='Test', user=self.user)
    BlogEntry.objects.create(title='Test', text='Test', user=self.user)
    BlogEntry.objects.create(title='Test', text='Test', user=self.user, is_published=False)

    response = self.c.get(reverse('entries'))
    #assert that context contains only published entries
    self.assertEqual(len(response.context['entries']), 2)
</code></pre></div></div>

<p>We created three entries. Only two of them are published.</p>

<p>###Assertion:</p>
<ul>
  <li>Entries page should only show 2 entries.</li>
</ul>

<p>Run the test and it will fail.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>======================================================================
FAIL: test_entries_template_context (blog.tests.BlogEntriesTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/akshar/play/dj/testcases/blog/tests.py", line 29, in test_entries_template_context
    self.assertEqual(len(response.context['entries']), 2)
AssertionError: 3 != 2

----------------------------------------------------------------------
</code></pre></div></div>

<p>Happened because we forgot to change our view. Our view still says <code class="highlighter-rouge">BlogEntry.objects.all()</code>. We should change it to <code class="highlighter-rouge">BlogEntry.published.all()</code>. Make this change and the test will pass.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def entries(request):
    entries = BlogEntry.published.all()
    return render_to_response("blog/entries.html", {'entries': entries})
</code></pre></div></div>

<p>So, <strong>response.context</strong> helped us find that we do not show more entries than we should.</p>

<p>##Test for pagination</p>

<p>Suppose we expect maximum ten entries to be available on each page. There are 15 entries in the db, so first page should show 10 entries and the second page should show 5. If user tries to access the third page a 404 page should be shown.</p>

<p>Our decided url pattern for getting entries on a particular page:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>url(r'^entries/(?P&lt;page&gt;\d+)/$', 'blog.views.entries_page', name='entries_page')
</code></pre></div></div>

<p>Writing the test:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_entries_page(self):
    for i in range(15):
        BlogEntry.objects.create(title="title", text="text", user=self.user, is_published=True)

    #access first page
    response = self.c.get(reverse("entries_page", args=[1,]))
    self.assertEqual(response.status_code, 200)
    self.assertEqual(len(response.context['entries']), 10)
    
    #access second page
    response = self.c.get(reverse("entries_page", args=[2,]))
    self.assertEqual(response.status_code, 200)
    self.assertEqual(len(response.context['entries']), 5)
</code></pre></div></div>

<p>Run the test and it will fail. Let’s add view to make it pass.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def entries_page(request, page):
    page = int(page)
    entries = BlogEntry.published.all()
    paginator = Paginator(entries, 10) #10 entries per page
    page_ = paginator.page(page)
    object_list = page_.object_list
    return render(request, "blog/entries_page.html", {"entries": object_list})
</code></pre></div></div>

<p>Test should pass now provided you have added the template.</p>

<p>Let’s try to access third page in the test. We need to add following in <code class="highlighter-rouge">test_entries_page</code> for that.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #access third page
    response = self.c.get(reverse("entries_page", args=[3,]))
    self.assertEqual(response.status_code, 404)
</code></pre></div></div>

<p>Running the test raises an error.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>....
raise EmptyPage('That page contains no results')
EmptyPage: That page contains no results
</code></pre></div></div>

<p>We find that there is a bug in our view and any page which doesn’t contain entries is not being handled as we want. Let’s change our view:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def entries_page(request, page):
    page = int(page)
    entries = BlogEntry.published.all()
    paginator = Paginator(entries, 10) #10 entries per page
    if page &gt; paginator.num_pages:
        raise Http404()
    page_ = paginator.page(page)
    object_list = page_.object_list
    return render(request, "blog/entries_page.html", {"entries": object_list})
</code></pre></div></div>

<p>Run the test again.</p>

<p>If you have a 404 template defined then your test will pass. In this project we do not have a 404 template and so we get another exception</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERROR: test_entries_page (blog.tests.BlogEntriesTest)
----------------------------------------------------------------------
Traceback (most recent call last):
....
    raise TemplateDoesNotExist(name)
TemplateDoesNotExist: 404.html
</code></pre></div></div>

<p>So, let’s add a 404 template. Test passes once we do it.</p>

<p>So, this test also helped us find a missing 404 template.</p>

<p>##Test for static files</p>

<p>You can look at <a href="http://agiliq.com/blog/2013/03/serving-static-files-in-django/">our blog on static file</a> if you have some confusion regarding how static files are served in Django.</p>

<p>We will create a <code class="highlighter-rouge">static</code> directory in our app <code class="highlighter-rouge">blog</code> and will put an image in this directory. Let’s say this image is <code class="highlighter-rouge">default.jpg</code></p>

<p>Let’s add a test to make sure this image is found by django static file handlers. This test makes us confident that we can expect this image to be served at <code class="highlighter-rouge">default.jpg</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from django.contrib.staticfiles import finders
from django.contrib.staticfiles.storage import staticfiles_storage

def test_images(self):
    abs_path = finders.find('default.jpg')
    self.assertTrue(staticfiles_storage.exists(abs_path))
</code></pre></div></div>

<p>Run the test and it should pass.</p>

<p>You can view the complete project <a href="https://github.com/akshar-raaj/Testing-in-Django">here</a>.</p>


       </div>
    </div>

    
  </body>
</html>

